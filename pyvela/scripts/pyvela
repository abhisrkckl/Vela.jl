#!/usr/bin/env python

import os
import shutil
from argparse import ArgumentParser
import sys
from timeit import timeit

import corner
import emcee
import numpy as np
from juliacall import Main as jl
from matplotlib import pyplot as plt
from pint.logging import setup as setup_log
from pyvela import Vela as vl
from pyvela import read_model_and_toas


def parse_args(argv):
    parser = ArgumentParser(
        description="Run single-pulsar timing & noise analysis using Vela.jl"
    )
    parser.add_argument("parfile", help="Pulsar ephemeris file", type=str)
    parser.add_argument("timfile", help="Pulsar TOA file", type=str)
    parser.add_argument(
        "-o", "--outdir", help="Output directory", default=".", type=str, required=True
    )
    parser.add_argument(
        "--cheat_prior_scale",
        help=(
            "Set the parameter prior to be a Uniform distribution centered at the value given in the par file "
            "with a width equal to `cheat_prior_scale * uncertainty_in_parfile`, unless a a default or custom "
            "prior is available"
        ),
        default=10,
        type=float,
    )
    parser.add_argument(
        "-N",
        "--nsteps",
        help="Number of steps for the MCMC sampler",
        default=6000,
        type=int,
    )
    parser.add_argument(
        "-b",
        "--burnin",
        help="Burn-in length for the MCMC chain",
        default=2000,
        type=int,
    )
    parser.add_argument(
        "-t", "--thin", help="Thinning length for the MCMC chain", default=100, type=int
    )
    parser.add_argument(
        "-r", "--resume", help="Resume from a previous run", action="store_true"
    )
    parser.add_argument(
        "-p",
        "--plot_only",
        help="Don't run the sampler, only plot previous results",
        action="store_true",
    )
    parser.add_argument(
        "--no_plot_params",
        help="Exclude these parameters from plotting",
        nargs="*",
        default=[]
    )
    parser.add_argument(
        "--plot_params",
        help="Include these parameters from plotting (supersedes --no_plot_params)",
        nargs="*",
        default=[]
    )

    args = parser.parse_args(argv)

    return args


def prepare_outdir(outdir: str, parfile: str, timfile: str):
    if not os.path.isdir(outdir):
        os.mkdir(outdir)

    datadir = f"{outdir}/data"
    if not os.path.isdir(datadir):
        os.mkdir(datadir)

    shutil.copy(parfile, datadir)
    shutil.copy(timfile, datadir)


def check_lnpost(lnpost, maxlike_params_v):
    print("Checking the log-posterior function...")
    print("lnpost(maxlike_params_v) = ", lnpost(maxlike_params_v))
    print(
        "Time per log-posterior call = ",
        timeit(
            "lnpost(maxlike_params_v)",
            globals={"lnpost": lnpost, "maxlike_params_v": maxlike_params_v},
            number=1000,
        ),
    )


def run_emcee(
    lnpost,
    prior_transform,
    param_names,
    nsteps,
    burnin,
    thin,
    outdir,
    resume,
    plot_only,
):
    ndim = len(param_names)
    nwalkers = ndim * 5
    p0 = (
        np.array([prior_transform(cube) for cube in np.random.rand(nwalkers, ndim)])
        if not resume
        else None
    )

    sampler = emcee.EnsembleSampler(
        nwalkers,
        ndim,
        lnpost,
        moves=[emcee.moves.StretchMove(), emcee.moves.DESnookerMove()],
        vectorize=True,
        # parameter_names=param_names,
        backend=emcee.backends.HDFBackend(f"{outdir}/chain.h5"),
    )

    if not plot_only:
        sampler.run_mcmc(p0, nsteps, progress=True, progress_kwargs={"mininterval": 1})

    chain = sampler.get_chain(flat=True, discard=burnin, thin=thin)
    lnprobs = sampler.get_log_prob(flat=True, discard=burnin, thin=thin)

    return chain, lnprobs


def plot_corner(samples, scale_factors, shifts, param_names, param_labels, pulsar_name, no_plot_params, plot_params, outdir):
    param_plot_mask = [
        idx
        for idx, par in enumerate(param_names)
        if (
            all(not par.startswith(pnp) for pnp in no_plot_params)
            or any(par.startswith(pnp) for pnp in plot_params)
        )
    ]

    samples_v = samples / scale_factors

    means = (np.mean(samples, axis=0) + shifts) / scale_factors
    stds = np.std(samples_v, axis=0)
    for idx, (pname, mean, std) in enumerate(zip(param_names, means, stds)):
        if idx in param_plot_mask:
            print(f"{pname}\t\t{mean}\t\t{std}")

    param_labels = [
        f"\n\n{label}\n\n"
        for idx, label in enumerate(param_labels)
        if idx in param_plot_mask
    ]
    samples_for_plot = samples_v[:, param_plot_mask]
    fig = corner.corner(
        samples_for_plot,
        labels=param_labels,
        label_kwargs={"fontsize": 11},
        range=[0.95] * len(param_labels),
        # truths=(maxlike_params_v[0] / scale_factors)[param_plot_mask],
        plot_datapoints=False,
        hist_kwargs={"density": True},
    )

    plt.suptitle(pulsar_name)
    plt.tight_layout()
    plt.savefig(f"{outdir}/corner.pdf")
    plt.show()


def plot_postfit_resids(mv, tv, samples, outdir):
    params_median = vl.read_params(mv, np.median(samples, axis=0))
    rv = (
        list(map(vl.value, vl.form_residuals(mv, tv, params_median)))
        if not jl.isa(tv[1], vl.WidebandTOA)
        else [vl.value(wr[0]) for wr in vl.form_residuals(mv, tv, params_median)]
    )

    ctoas = [vl.correct_toa(mv, tvi, params_median) for tvi in tv]
    errs = np.sqrt(
        [vl.value(vl.scaled_toa_error_sqr(tvi, ctoa)) for (tvi, ctoa) in zip(tv, ctoas)]
    )

    mjds = [float(vl.value(tvi.value)) for tvi in tv]

    plt.errorbar(
        mjds,
        rv,
        errs,
        ls="",
        marker="+",
        color="blue",
    )
    plt.axhline(0, color="grey", ls="dotted")
    plt.xlabel("MJD")
    plt.ylabel("Residuals (s)")
    plt.suptitle(mv.pulsar_name)
    plt.tight_layout()
    plt.savefig(f"{outdir}/postfit.pdf")
    plt.show()


def main(argv):
    setup_log(level="WARNING")

    args = parse_args(argv)

    prepare_outdir(args.outdir, args.parfile, args.timfile)

    mv, tv = read_model_and_toas(
        args.parfile, args.timfile, cheat_prior_scale=args.cheat_prior_scale
    )

    vectorize = True

    lnpost = vl.get_lnpost_func(mv, tv, vectorize)
    prior_transform = vl.get_prior_transform_func(mv)

    param_names = vl.get_free_param_names(mv.param_handler)
    param_labels = vl.get_free_param_labels(mv)
    scale_factors = vl.get_scale_factors(mv.param_handler)

    maxlike_params_v = np.array([vl.read_param_values_to_vector(mv.param_handler)])

    shifts = [
        (float(mv.param_handler._default_params_tuple.F_.x) if pname == "F0" else 0)
        for pname in param_names
    ]

    check_lnpost(lnpost, maxlike_params_v)

    samples, lnprs = run_emcee(
        lnpost,
        prior_transform,
        list(param_names),
        args.nsteps,
        args.burnin,
        args.thin,
        args.outdir,
        args.resume,
        args.plot_only,
    )

    plot_corner(
        samples, scale_factors, shifts, param_names, param_labels, mv.pulsar_name, args.no_plot_params, args.plot_params, args.outdir
    )

    plot_postfit_resids(mv, tv, samples, args.outdir)


if __name__ == "__main__":
    main(sys.argv[1:])
