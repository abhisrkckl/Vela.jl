var documenterSearchIndex = {"docs":
[{"location":"precision/#Precision","page":"Precision","title":"Precision","text":"","category":"section"},{"location":"precision/","page":"Precision","title":"Precision","text":"Pulsar timing is one of the most precise techniques in science. This means that we often deal with quantities of immense dynamic range which cannot be represented using double-precision floating point (Float64) numbers. The quantities where more than double precision is necessary include the pulse time of arrivals (TOAs), pulse phases, and pulsar rotational frequencies. ","category":"page"},{"location":"precision/","page":"Precision","title":"Precision","text":"In tempo2 and PINT, these quantities are represented using the long double type available in  C/C++ (PINT uses numpy.longdouble, which uses C long double internally). Unfortunately, sizeof(long double) is not fixed by the C and C++ standards, and in some hardware it can be  the same as the double type (e.g., the Apple Mx machines). In such cases, tempo2 falls back to  the __float128 type which is available as a compiler extension in gcc, whereas PINT  does not work at all.","category":"page"},{"location":"precision/","page":"Precision","title":"Precision","text":"To avoid this harware dependency, Vela.jl represents these quantities using the Double64 type available in DoubleFloats.jl. This package implements the double-double arithmetic  (Decker 1971) which treats an extended-precision number  as a sum of two Float64s. Further, Double64 is faster than the software-implemented Float128  type from the Quadmath.jl package which uses __float128 under the hood.","category":"page"},{"location":"precision/","page":"Precision","title":"Precision","text":"Please note that although the core of the Vela.jl package should be hardware-independent, its full functionality won't be available in machines where PINT won't work, because it relies on  PINT to do certain one-time computations such as clock corrections.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Vela.jl can be installed directly from GitHub. We recommend installing it within a dedicated  conda environment.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Please note that Vela.jl is only tested against Python 3.12 and Julia 1.10 in Ubuntu at present.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you don't have Julia installed, please install it following the instructions found  here.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Now install the Python dependencies and set the environment variables. The most important one is PYTHON_JULIACALL_HANDLE_SIGNALS. If it is not set properly you'll get segmentation faults.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(base) $ # Setup conda environment\n(base) $ conda create -n vela python=3.12\n(base) $ conda activate vela\n(vela) $ conda install -c conda-forge pyjuliacall pint-pulsar black emcee nestle corner tqdm pytest pytest-xdist\n(vela) $ conda env config vars set PYTHON_JULIACALL_HANDLE_SIGNALS=yes\n(vela) $ conda env config vars set PYTHON_JULIACALL_THREADS=4\n(vela) $ conda env config vars set JULIA_NUM_THREADS=4\n(vela) $ conda env config vars set JULIA_CONDAPKG_BACKEND=\"Null\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Now install the Julia packages.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ julia\njulia> import Pkg\njulia> Pkg.add([\"LocalRegistry\", \"JuliaFormatter\", \"BenchmarkTools\", \"PythonCall\"])\njulia> Pkg.Registry.add(url=\"https://github.com/abhisrkckl/julia_registry\")\njulia> Pkg.add(url=\"https://github.com/abhisrkckl/Vela.jl\")\njulia> exit()","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install the Python interface pyvela.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ pip install git+https://github.com/abhisrkckl/Vela.jl","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The number of threads available to Vela.jl for parallel processing can be controlled  using the environment variables JULIA_NUM_THREADS (for direct use from Julia) or  PYTHON_JULIACALL_THREADS (for use from within Python).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The pyvela/examples directory provides several example datasets and scripts. A basic example (using the Python wrapper) can be run like this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ ./run_example_emcee.py NGC6440E.par NGC6440E.tim","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Each TimingModel has a number of model parameters, some of which are free and some frozen. Some of these parameters are single parameters, like the sky coordinates RAJ and DECJ, and are  represented by the Parameter type. Some come as families of similar parameters, such as the pulsar frequency F0 and its derivatives F1, F2, etc. These are represented as  MultiParameters. These contain information about parameter names, their original units (used by PINT), the scaling factors for converting to and from the Vela.jl units, default values, whether they are free/frozen, etc. ","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Parameter\nMultiParameter","category":"page"},{"location":"parameters/#Vela.Parameter","page":"Parameters","title":"Vela.Parameter","text":"Parameter\n\nA single model parameter.\n\nCorresponds to floatParameter, AngleParameter, or MJDParameter in PINT.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Vela.MultiParameter","page":"Parameters","title":"Vela.MultiParameter","text":"MultiParameter\n\nA set of model parameters that are characterized by a common name and a varying index.\n\nCorresponds to maskParameter or prefixParameter in PINT.\n\n\n\n\n\n","category":"type"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"The correct_toa methods expect the parameters to be passed in as a NamedTuple containing  GQs for single Parameters and NTuples of GQs for MultiParameters. In general, the  samplers the parameter values input from a sampler will be some type of ordered collection of Float64s like a list, ndarray, Vector, etc. This is converted into a NamedTuple of  appropriate structure by the read_params function. The opposite can be achieved using the read_param_values_to_vector function. The information needed to do these transformations  is stored in the ParamHandler type.","category":"page"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"read_params\nread_param_values_to_vector\nParamHandler","category":"page"},{"location":"parameters/#Vela.read_params","page":"Parameters","title":"Vela.read_params","text":"read_params(ph::ParamHandler{PT}, free_values)::PT where {PT<:NamedTuple}\n\nCreate a parameter tuple from a collection of free parameter values.\n\nReverse of read_param_values_to_vector().\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.read_param_values_to_vector","page":"Parameters","title":"Vela.read_param_values_to_vector","text":"Generate a collection of free parameter values from a parameter tuple.\n\nReverse of read_params()\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.ParamHandler","page":"Parameters","title":"Vela.ParamHandler","text":"ParamHandler{PT<:NamedTuple}\n\nHandles the creation of a parameter tuple from a collection of free parameter values.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#The-Timing-and-Noise-Model","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The pulsar timing & noise model (a.k.a. pulsar ephemeris) is a generative mathematical model for the TOA measurements and uncertainties (and the DM measurements & uncertainties in the wideband paradigm). The timing residuals are the differences between measured TOAs and the TOAs predicted by the timing model. See Hobbs+ 2006 and  Edwards+ 2006 for details.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The physical and instrumental effects that affect one TOA at a time are represented as Components, and the effects that are correlated across multiple TOAs are modeled as a Kernel.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Component","category":"page"},{"location":"timing-model/#Vela.Component","page":"The Timing & Noise Model","title":"Vela.Component","text":"Component\n\nAbstract base type of all timing & noise model components which affect one TOA at a time.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Each component has a correct_toa method which produces a TOA correction.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"correct_toa","category":"page"},{"location":"timing-model/#Vela.correct_toa","page":"The Timing & Noise Model","title":"Vela.correct_toa","text":"correct_toa(::Component, ::TOABase, ::TOACorrectionBase, ::NamedTuple)\n\nCorrect the TOA using a delay, phase, observing frequency shift, uncertainty scaling, doppler factor, etc.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Kernels will be discussed in its own section.","category":"page"},{"location":"timing-model/#TOA-corrections","page":"The Timing & Noise Model","title":"TOA corrections","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Such a correction can be one or more of the following:     1. A delay that modifies the TOA value     2. A phase correction that modifies the TOA phase     3. A Doppler correction that modifies the observing frequency and the pulsar spin frequency     4. An EFAC or EQUAD that modifies the TOA uncertainty     5. A DM correction that modifies the wideband DM measurement     6. A DMEFAC or DMEQUAD that modifies the wideband DM uncertainty","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The accumlated TOA corrections are represented by the TOACorrection and WidebandTOACorrection types, which are derived from TOACorrectionBase.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"TOACorrectionBase\nTOACorrection\nWidebandTOACorrection","category":"page"},{"location":"timing-model/#Vela.TOACorrectionBase","page":"The Timing & Noise Model","title":"Vela.TOACorrectionBase","text":"TOACorrectionBase\n\nAn abstract base class representing accumulated timing & noise model corrections applied to a TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.TOACorrection","page":"The Timing & Noise Model","title":"Vela.TOACorrection","text":"TOACorrection\n\nThe accumulated timing & noise model corrections applied to a narrowband TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.WidebandTOACorrection","page":"The Timing & Noise Model","title":"Vela.WidebandTOACorrection","text":"WidebandTOACorrection\n\nThe accumulated timing & noise model corrections applied to a wideband TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The following methods extract some of the intermediate-corrected quantities of interest.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"corrected_toa_value\ndoppler_corrected_observing_frequency\ndoppler_shifted_spin_frequency\nscaled_toa_error_sqr\nscaled_dm_error_sqr\nphase_residual\ndm_residual","category":"page"},{"location":"timing-model/#Vela.corrected_toa_value","page":"The Timing & Noise Model","title":"Vela.corrected_toa_value","text":"TOA value after delay correction.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.doppler_corrected_observing_frequency","page":"The Timing & Noise Model","title":"Vela.doppler_corrected_observing_frequency","text":"Observing frequency in the barycentric or pulsar frame, depending on the correction level. The observing_frequency is originally in the topocentric frame.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.doppler_shifted_spin_frequency","page":"The Timing & Noise Model","title":"Vela.doppler_shifted_spin_frequency","text":"doppler_shifted_spin_frequency(::TOACorrection)\n\nSpin frequency in topocentric or barycentric frame, depending on the correction level. The spin_frequency is originally in the pulsar frame.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.scaled_toa_error_sqr","page":"The Timing & Noise Model","title":"Vela.scaled_toa_error_sqr","text":"scaled_toa_error_sqr(toa::TOA, toacorr::TOACorrection)\n\nSquared TOA uncertainty after applying EFAC and EQUAD.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.scaled_dm_error_sqr","page":"The Timing & Noise Model","title":"Vela.scaled_dm_error_sqr","text":"scaled_dm_error_sqr(::DMInfo, ::DMInfoCorrection)\n\nSquared DM uncertainty after applying DMEFAC and DMEQUAD.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.phase_residual","page":"The Timing & Noise Model","title":"Vela.phase_residual","text":"phase_residual(::TOA, ::TOACorrection)\n\nTOA phase residual\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.dm_residual","page":"The Timing & Noise Model","title":"Vela.dm_residual","text":"dm_residual(::DMInfo, ::DMInfoCorrection)\n\nCompute DM residual corresponding to a wideband TOA.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"There are three types of Components as shown below based on what type of corrections they provide.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(Component, maxdepth=1)))","category":"page"},{"location":"timing-model/#Delay-components","page":"The Timing & Noise Model","title":"Delay components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DelayComponents correct the measured TOA by subtracting certain delays.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DelayComponent","category":"page"},{"location":"timing-model/#Vela.DelayComponent","page":"The Timing & Noise Model","title":"Vela.DelayComponent","text":"DelayComponent\n\nAbstract base type of all timing model components which contribute a time delay correction to a TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DelayComponent has further subtypes which represent different physical processes producing delays.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(DelayComponent, maxdepth=1)))","category":"page"},{"location":"timing-model/#Solar-system-delays","page":"The Timing & Noise Model","title":"Solar system delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"SolarSystem","category":"page"},{"location":"timing-model/#Vela.SolarSystem","page":"The Timing & Noise Model","title":"Vela.SolarSystem","text":"Solar system Rømer delay, Parallax delay, and Shapiro delay.\n\nCorresponds to AstrometryEquatorial, AstrometryEcliptic,  and SolarSystemShapiro in PINT.\n\nReference:     Edwards+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"In addition to a delay, SolarSystem also producess a Doppler correction which applies to the observing frequency and the pulsar spin frequency. ","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"This component barycenters the TOA. It will skip TOAs that are already barycentered, e.g., TOAs measured using space-based telescopes. The is_barycentered function checks whether a TOA has been barycentered.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"is_barycentered","category":"page"},{"location":"timing-model/#Vela.is_barycentered","page":"The Timing & Noise Model","title":"Vela.is_barycentered","text":"is_barycentered(::TOA)::Bool\n\nChecks if a TOA has been barycentered.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Dispersion-delays","page":"The Timing & Noise Model","title":"Dispersion delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionComponents represent the dispersion of the radio waves due to the free electrons present along the line of sight to the pulsar. This may include the ionized interstellar medium as well as  solar wind.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionComponent","category":"page"},{"location":"timing-model/#Vela.DispersionComponent","page":"The Timing & Noise Model","title":"Vela.DispersionComponent","text":"DispersionComponent\n\nAbstrct base type of all timing model components which provide a dispersion measure correction.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionComponents provide a delay and a DM correction (for wideband TOAs), which are related by the equation Delta_textDM = K * textDM  nu^2. The dispersion correction is computed via  the dispersion_slope function.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"dispersion_slope","category":"page"},{"location":"timing-model/#Vela.dispersion_slope","page":"The Timing & Noise Model","title":"Vela.dispersion_slope","text":"dispersion_slope(::DispersionComponent, ::TOA, ::TOACorrection, ::NamedTuple)\n\nCompute the dispersion slope corresponding to a TOA. \n\n\n\n\n\n","category":"function"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The DispersionComponents available in Vela.jl are","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(DispersionComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The most basic DispersionComponent is DispersionTaylor.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionTaylor","category":"page"},{"location":"timing-model/#Vela.DispersionTaylor","page":"The Timing & Noise Model","title":"Vela.DispersionTaylor","text":"Taylor series representation of the dispersion measure.\n\nCorresponds to DispersionDM in PINT.\n\nReference:     Backer & Hellings 1986\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DMWaveX and PowerlawDispersionNoiseGP provide two representations of the dispersion noise / stochastic DM variations.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DMWaveX\nPowerlawDispersionNoiseGP","category":"page"},{"location":"timing-model/#Vela.DMWaveX","page":"The Timing & Noise Model","title":"Vela.DMWaveX","text":"DMWaveX\n\nAn unconstrained Fourier series representation of the dispersion noise.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PowerlawDispersionNoiseGP","page":"The Timing & Noise Model","title":"Vela.PowerlawDispersionNoiseGP","text":"PowerlawDispersionNoiseGP\n\nA Fourier series Gaussian process representation of the dispersion noise where the  power spectral density is assumed to be a power law.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"See also Red noise models.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"SolarWind is a simple model for solar wind dispersion.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"SolarWindDispersion","category":"page"},{"location":"timing-model/#Vela.SolarWindDispersion","page":"The Timing & Noise Model","title":"Vela.SolarWindDispersion","text":"Solar wind model assuming a spherically symmetric distribution of electrons which falls off as an inverse-square function of the distance from the Sun.\n\nReference:     Edwards+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionJump and DispersionOffset represent two types of system-dependent dispersion  offsets.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionJump\nDispersionOffset","category":"page"},{"location":"timing-model/#Vela.DispersionJump","page":"The Timing & Noise Model","title":"Vela.DispersionJump","text":"System-dependent wideband DM offsets (DMJUMP) with non-exclusive selection masks.\n\nUnlike an FDJUMPDM, a DMJUMP only provides a DM correction and no delay.\n\nReference:     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.DispersionOffset","page":"The Timing & Noise Model","title":"Vela.DispersionOffset","text":"DispersionOffset\n\nSystem-dependent DM offsets (FDJUMPDM) with non-exclusive selection masks.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Chromatic-delays","page":"The Timing & Noise Model","title":"Chromatic delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Chromatic delays are similar to dispersion delays, but have a different powerlaw dependence  on the observing frequency. Such delays can occur due to interstellar scattering or  frequency-dependent dispersion. A chromatic delay is given by Delta_textCM = K * textCM  nu^alpha where CM is called the chromatic measure, and alpha is called the chromatic index. The effect of chromatic effects on wideband TOAs is not well-understood.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(ChromaticComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"ChromaticTaylor\nCMWaveX\nPowerlawChromaticNoiseGP","category":"page"},{"location":"timing-model/#Vela.ChromaticTaylor","page":"The Timing & Noise Model","title":"Vela.ChromaticTaylor","text":"ChromaticTaylor\n\nTaylor series representation of the chromatic measure.\n\nCorresponds to ChromaticCM in PINT.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.CMWaveX","page":"The Timing & Noise Model","title":"Vela.CMWaveX","text":"CMWaveX\n\nA Fourier series representation of the variable-index chromatic red noise.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PowerlawChromaticNoiseGP","page":"The Timing & Noise Model","title":"Vela.PowerlawChromaticNoiseGP","text":"PowerlawDispersionNoiseGP\n\nA Fourier series Gaussian process representation of the chromatic noise where the  power spectral density is assumed to be a power law.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"See also Red noise models.","category":"page"},{"location":"timing-model/#Binary-delays","page":"The Timing & Noise Model","title":"Binary delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Similar to solar system delays, the binary motion of the pulsar also introduces various  delays to the TOAs, including Rømer delay, Shapiro delay, and Einstein delay. ","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"BinaryComponent","category":"page"},{"location":"timing-model/#Vela.BinaryComponent","page":"The Timing & Noise Model","title":"Vela.BinaryComponent","text":"BinaryComponent\n\nAbstract base type of all binary components.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Different binary models are used based on the properties of the binary orbit.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(BinaryComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Vela.jl has two families of binary models. The ELL1 family is used for nearly circular binaries and the DD family is used for eccentric orbits. The different models are characterized by their treatment of Shapiro delay, Kopeikin corrections, etc.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"BinaryDD\nBinaryDDH\nBinaryDDK\nBinaryDDS\nBinaryELL1\nBinaryELL1H","category":"page"},{"location":"timing-model/#Vela.BinaryDD","page":"The Timing & Noise Model","title":"Vela.BinaryDD","text":"The Damour & Deruelle binary model for eccentric binaries.\n\nReference:     Damour & Deruelle 1986\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryDDH","page":"The Timing & Noise Model","title":"Vela.BinaryDDH","text":"The Damour & Deruelle model for eccentric binaries with orthometric parametrization of the Shapiro delay. Used for low to moderate inclination binaries.\n\nReferences:     Damour & Deruelle 1986,      Freire & Wex 2010,     Weisberg & Huang 2016\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryDDK","page":"The Timing & Noise Model","title":"Vela.BinaryDDK","text":"The Damour & Deruelle model for eccentric binaries with Kopeikin corrections included, which account for the apparent changes in the orbital elements due to proper motion and  parallax.\n\nReferences:     Damour & Deruelle 1986,     Kopeikin 1995,     Kopeikin 1996\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryDDS","page":"The Timing & Noise Model","title":"Vela.BinaryDDS","text":"The Damour & Deruelle model for eccentric binaries with an alternative parametrization of Shapiro delay applicable to almost edge-on orbits.\n\nReferences:     Damour & Deruelle 1986,     Kramer+ 2006,     Rafikov & Lai 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryELL1","page":"The Timing & Noise Model","title":"Vela.BinaryELL1","text":"A binary model representing a nearly circular orbit.\n\nReference:     Lange+ 2001\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryELL1H","page":"The Timing & Noise Model","title":"Vela.BinaryELL1H","text":"A binary model representing a nearly circular orbit with orthometric  parametrization of the Shapiro delay. The Shapiro delay computed in this model does not include the Fourier components that are fully covariant with the Rømer delay.\n\nReference:     Lange+ 2001,     Freire & Wex 2010\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Frequency-dependent-delays","page":"The Timing & Noise Model","title":"Frequency-dependent delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Unmodeled frequency-dependent profile evolution can manifest as frequency-dependent delays in narrowband TOAs. These are taken care during timing using certain phenomenological  models listed below.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"FrequencyDependent\nFrequencyDependentJump","category":"page"},{"location":"timing-model/#Vela.FrequencyDependent","page":"The Timing & Noise Model","title":"Vela.FrequencyDependent","text":"FrequencyDependent\n\nA frequency-dependent delay to account for frequency-dependent profile evolution.\n\nReference:     Arzoumanian+ 2015\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.FrequencyDependentJump","page":"The Timing & Noise Model","title":"Vela.FrequencyDependentJump","text":"FrequencyDependentJump\n\nA system- & frequency-dependent delay to account for frequency-dependent profile evolution. This is useful while combining TOAs generated by different experiments with different TOA measurement procedures.\n\nReference:     Susobhanan+ 2015\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Spin-noise","page":"The Timing & Noise Model","title":"Spin noise","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Rotational irregularities of the pulsar causes stochastic modulations on the TOAs. We represent these modulations as a Fourier series in time.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"WaveX\nPowerlawRedNoiseGP    ","category":"page"},{"location":"timing-model/#Vela.WaveX","page":"The Timing & Noise Model","title":"Vela.WaveX","text":"An unconstrained Fourier series representation of the achromatic red noise.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PowerlawRedNoiseGP","page":"The Timing & Noise Model","title":"Vela.PowerlawRedNoiseGP","text":"PowerlawRedNoiseGP\n\nA Fourier series Gaussian process representation of the achromatic red noise where the  power spectral density is assumed to be a power law.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"See also Red noise models.","category":"page"},{"location":"timing-model/#Phase-components","page":"The Timing & Noise Model","title":"Phase components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"A PhaseComponent contributes to the phase computation from a delay-corrected TOA.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"PhaseComponent","category":"page"},{"location":"timing-model/#Vela.PhaseComponent","page":"The Timing & Noise Model","title":"Vela.PhaseComponent","text":"PhaseComponent\n\nAbstract base type of all timing model components which contribute a phase correction to a TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The hierarchy of PhaseComponents is given below.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(PhaseComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Spindown\nGlitch\nPhaseOffset\nPhaseJump","category":"page"},{"location":"timing-model/#Vela.Spindown","page":"The Timing & Noise Model","title":"Vela.Spindown","text":"Rotation or the pulsar represented as a Taylor series in spin frequency.\n\nCorresponds to Spindown in PINT.\n\nReference:     Backer & Hellings 1986\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.Glitch","page":"The Timing & Noise Model","title":"Vela.Glitch","text":"Glitches in pulsar rotation.\n\nReference:     Hobbs+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PhaseOffset","page":"The Timing & Noise Model","title":"Vela.PhaseOffset","text":"Phase offset between measured TOAs and the TZR TOA.\n\nCorresponds to PhaseOffset in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PhaseJump","page":"The Timing & Noise Model","title":"Vela.PhaseJump","text":"System-dependent phase jumps with non-exclusive selection masks.\n\nReference:     Hobbs+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#White-noise-components","page":"The Timing & Noise Model","title":"White noise components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"These components modify the TOA or DM uncertainty in some manner.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(WhiteNoiseComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"MeasurementNoise\nDispersionMeasurementNoise","category":"page"},{"location":"timing-model/#Vela.MeasurementNoise","page":"The Timing & Noise Model","title":"Vela.MeasurementNoise","text":"Modifications to the measured TOA uncertainties:  EFACs (error factors) and EQUADs (errors added in quadrature). Assumes that the EFACs & EQUADs are exclusive.\n\nReference:     Lentati+ 2014\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.DispersionMeasurementNoise","page":"The Timing & Noise Model","title":"Vela.DispersionMeasurementNoise","text":"Modifications to the measured wideband DM uncertainties: DMEFACs and DMEQUADs. Assumes that the DMEFACs & DMEQUADs are exclusive.\n\nReference:     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Order-of-components","page":"The Timing & Noise Model","title":"Order of components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"It should be noted that the action of different Components do not commute in general. Therefore,  they must be applied in the correct order to get sensible results. The order followed by Vela.jl  is roughly as follows:","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"1. Delay corrections\n    a. Solar system effects\n    b. Interstellar medium effects\n    c. Pulsar binary effects\n2. Phase computation\n    a. Pulsar rotational effects\n3. Uncertainty corrections\n    a. Measurement noise corrections","category":"page"},{"location":"timing-model/#The-TZR-TOA","page":"The Timing & Noise Model","title":"The TZR TOA","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The pulse phases are measured with respect to a fictitious fiducial TOA called the TZR TOA. This is represented using the TOA class, but is distinguished from physical TOAs using the  tzr attribute. The make_tzr_toa function creates a TZR TOA and the is_tzr function checks  whether a TOA is a TZR TOA.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"make_tzr_toa\nis_tzr","category":"page"},{"location":"timing-model/#Vela.make_tzr_toa","page":"The Timing & Noise Model","title":"Vela.make_tzr_toa","text":"make_tzr_toa(tzrtdb::GQ{Double64}, tzrfreq::GQ{Float64}, tzrephem::SolarSystemEphemeris)::TOA\n\nCreate a TZR TOA object.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.is_tzr","page":"The Timing & Noise Model","title":"Vela.is_tzr","text":"is_tzr(::TOA)::Bool\n\nChecks if a TOA is a TZR TOA.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#The-TimingModel-type","page":"The Timing & Noise Model","title":"The TimingModel type","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"A timing & noise model is represented by the TimingModel type. ","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"TimingModel","category":"page"},{"location":"timing-model/#Vela.TimingModel","page":"The Timing & Noise Model","title":"Vela.TimingModel","text":"The pulsar timing & noise model.\n\nSupports both narrowband and wideband timing.\n\nCorresponds to TimingModel in PINT.\n\nReferences:     Edwards+ 2006,     Lentati+ 2014,     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"It has the following contents:     1. Pulsar name (PSR), solar system ephemeris name (EPHEM), name of the TT timescale realization (CLOCK), etc.     2. An ordered collection of Components     3. A Kernel     4. A ParamHandler containing information about model parameters.     5. An ordered collection of Priors for each free parameter","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Some of these are explained in the following sections.","category":"page"},{"location":"quantities/#Quantities","page":"Quantities","title":"Quantities","text":"","category":"section"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"It turns out that we can write the entire pulsar timing formula (e.g., see Equations 1-2 of  Susobhanan+ 2024) can be expressed such that all quantities appearing therein have dimensions of the form [T^n]. In practice, this is achieved by absorbing certain constants appearing in the timing formula into measurable quantities.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"For example, DM -> DMconst*DM; M2 -> G*M2/c^3; PX -> PX*c/AU; etc.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"This means that we can represent all quantities in pulsar timing in the form x*s^p after some scaling, where x is the value of the scaled quantity in SI units, s is second, and p is an integer. This is implemented in the GeometricUnits.jl package as the GQ{p,F<:AbstractFloat} type (with p ∈ Integer). This package overloads all the arithmetic and comparison operators as well as elementary mathematical functions for the GQ type. i.e., GQ types can be used just like Numbers in most places through the magic of mutiple dispatch.  (GQs do not behave identically to Numbers in some contexts, so GQ is not a subtype of Number.) It also defines iterators and such for the GQ type so that we can use it with packages like LinearAlgebra.jl","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"GQ","category":"page"},{"location":"quantities/#GeometricUnits.GQ","page":"Quantities","title":"GeometricUnits.GQ","text":"GQ{X<:AbstractFloat}\n\nRepresents a quantity with dimensions T^d. A GQ can be represented mathematically as x s^d where d  ℤ.\n\n\n\n\n\n","category":"type"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"Note that the dimensionality p is a type parameter, which means that the dimensional correctness will be enforced by the Julia language at \"compile time\", and it will refuse to execute dimensionally  incorrect expressions. This provides strong assurances for code correctness. Further, since p is  a type parameter, there is no run time penalty for ensuring dimensional correctness.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"GeometricUnits.jl also implements the following operations.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"1. Unary `+` and `-` operators for all `GQ` types\n2. Binary `+` and `-` operators for `GQ` types with like dimensions\n3. `*`, `/` operators for all `GQ` types\n4. `^` operator for various cases where the output is a valid `GQ`\n5. `sqrt` `cbrt`, `root` functions for cases where the output is a valid `GQ`\n6. `==`, `!=`, `<`, `<=`, `>`, `>=`, `≈` operators for `GQ` types with like dimensions\n7. Trigonometric functions (`sin`, `cos`, `tan`, `csc`, `sec`, `cot`) for dimensionless inputs\n8. Inverse trigonometric functions (`asin`, `acos`, `atan`, `acsc`, `asec`, `acot`) for dimensionless inputs \n9. `atan` function for a pair of  `GQ`s types with like dimensions\n10. `exp`, `exp2`, `exp10`, `log`, `log2`, `log10` functions for dimensionless inputs\n11. `abs`, `sign`, `floor`, `ceil` functions for all `GQ` types\n12. `isfinite` and `isnan` functions for all `GQ` types","category":"page"},{"location":"red-noise/#Red-noise-models","page":"Red noise models","title":"Red noise models","text":"","category":"section"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"A time-correlated stochastic process whose power spectral density is a decreasing function of the conjugate frequency (not to be confused with observing frequency) is known as red noise. Depending on the pulsar, different types of red noise processes will be present in the TOAs, including spin noise, dispersion noise, and the stochastic gravitational wave background.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Such a process is usually modeled as truncated Fourier series.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Delta(t) = (fracnu_textrefnu)^alpha sum_j=1^N  a_jcos(2pi j f_1(t-t_0)) + b_jsin(2pi j f_1(t-t_0)) ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"where nu is the observing frequency, nu_textref is a reference frequency, alpha is the chromatic index, N is the number of harmonics, f_1 is the fundamental frequency, t_0 is a fiducial  time, and a_j and b_j are Fourier coefficients.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Two types of red noise models are currently available in Vela.jl. ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"The WaveX family of models treat the Fourier coefficients as unconstrained free parameters  (e.g., WXSIN_ and WXCOS_).","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"The PowerlawRedNoiseGP family of models treat these coefficients as Gaussian random variables whose variances, interpreted as power spectral densities, follow a power law spectrum.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlangle a_j rightrangle = leftlangle b_j rightrangle = 0","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlangle a_j a_k rightrangle = leftlangle b_j b_k rightrangle = sigma_j^2 delta_jk","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlangle a_j b_k rightrangle = 0","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"sigma_j = P(f_j) = fracA^212pi^2 f_textyr^3 f_1 left(fracf_textyrfright)^gamma","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"where A is the powerlaw amplitude gamma is the powerlaw index, and f_textyr=1 textyr^-1. The prior parameters A and gamma are also treated as free parameters and sampled over. However, in this case, the geometry of the parameter space exhibits Neil's funnel-like geometry, which is hard for MCMC samplers to deal with. To avoid this, we use bara_j=a_jsigma_j and  barb_j=b_jsigma_j as free parameters where ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlanglebara_j^2rightrangle = leftlanglebarb_j^2rightrangle = 1","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"In PowerlawRedNoiseGP, this is represented by the parameters PLREDSIN_ and PLREDCOS_. The powerlaw parameters are PLREDAMP and PNREDGAM. Please note that the PINT-format par files do not support PLREDSIN_ and PLREDCOS_. Hence, while they are included in the posterior samples, they will not be included in the output par file.  ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Similar representations also exist for dispersion noise (alpha=2) and chromatic noise (see Dispersion delays and Chromatic delays).","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Other types of spectral models such as free spectrum, t-process, broken powerlaw, running power law, etc are not yet implemented.","category":"page"},{"location":"pyvela/#Getting-started:-The-pyvela-interface","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Vela.jl must interact with Python for three reasons: (1) most pulsar astronomers are more  familiar with Python than Julia (2) Python has many samplers that have no counterpart in  Julia, and most importantly, (3) it is a real pain to implement par and tim file readers.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The pyvela interface is demonstrated below using an example with the emcee sampler.","category":"page"},{"location":"pyvela/#Reading-par-and-tim-files-using-the-SPNTA-class","page":"Getting started: The pyvela interface","title":"Reading par and tim files using the SPNTA class","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"While the par file format is outwardly simple, it is rife with special cases and arbitrary units, and reconstructing a timing & noise model from a par file is pretty hard. The tim files are kind of easier to handle, but there are multiple tim file formats and some datasets can have multiple format TOAs in the same file. So we are not re-inventing the wheel and instead using PINT to do this. This also has the advantage of not having to implement clock corrections and solar system ephemeris calculations.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Here is how we read read a pair of par and tim files in pyvela:","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"from pyvela import SPNTA, Vela as vl\nfrom juliacall import Main as jl\nimport numpy as np\n\njl.seval(\"using Distributions\")\n\nparfile, timfile = \"NGC6440E.par\", \"NGC6440E.tim\"\nspnta = SPNTA(\n    parfile, \n    timfile,\n    cheat_prior_scale=5,\n    custom_priors={\n        \"PHOFF\": jl.Uniform(-0.5, 0.5)\n    }\n)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Here, spnta.model is a Vela.TimingModel object and spnta.toas is a Vector{Vela.TOA} object. The SPNTA class function reads the par and tim files using the pint.models.get_model_and_toas  function under the hood and converts the resulting pint.models.TimingModel and pint.toa.TOAs objects. Note that this conversion does  not conserve all the information, and the reverse is not possible. ","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"cheat_prior_scale defines the scale factor by which the frequentist uncertainties are multiplied to  obtain the \"cheat\" prior widths. The custom_priors argument contains the user-defined prior distributions,  which should be instances of the  Distributions.UnivariateDistribution type. It supports both parameter names  and prefixes as dict keys. For example, if an entry for \"EFAC\" is present, it will set the prior for all  EFAC parameters. If \"EFAC1\" is present, it will set the prior for EFAC1 specifically. If both \"EFAC\" and  \"EFAC1\" are present, the latter sets the prior for EFAC1, whereas the former sets the priors for all other EFACs.  In the above example, the priors for all parameters except \"PHOFF\" are set using \"cheat\" priors.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The custom_priors argument also accepts a filename (str) or an IO object containing a JSON representation of  the priors. See Representing priors in a JSON file for more details.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Everything defined in Vela.jl will be available through the vl namespace above, e.g., vl.TimingModel  and vl.TOA. Things that were explicitly imported into Vela.jl are also available, e.g., vl.GQ is the GQ type  from GeometricUnits.jl. Other things from Julia are accessed using the juliacall package.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The SPNTA object created above has attributes lnlike, lnprior, prior_transform, lnpost, and  lnpost_vectorized. These provide the log-likelihood, log-prior, prior transform, and log-posterior  functions which call Vela.jl under the hood. The difference between spnta.lnpost and  spnta.lnpost_vectorized is that if multiple threads are allowed (by setting the PYTHON_JULIACALL_THREADS environment variable), spnta.lnpost parallelizes a single log-posterior computation across TOAs, whereas spnta.lnpost_vectorized computes the log-posterior at multiple points in the parameter space parallelly. The latter can be used with samplers such as emcee and zeus. Make sure not to set PYTHON_JULIACALL_THREADS  to a value greater than the number of available CPU cores.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The SPNTA object also has useful attributes such as the number of free parameters (ndim), the free parameter names (param_names), free parameter labels including units (param_labels), scale factors for converting to and from the Vela.jl internal units (scale_factors), and the default parameters read from the par file (maxlike_params). The rescale_samples() function rescales the samples from Vela.jl internal units to the usual units used in pulsar astronomy.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Now, let us see if lnpost actually works.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"print(spnta.lnpost(spnta.maxlike_params))","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Similarly,","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"print(\n    spnta.lnpost_vectorized(\n        np.array([spnta.maxlike_params])\n    )\n)","category":"page"},{"location":"pyvela/#Setting-up-the-sampler","page":"Getting started: The pyvela interface","title":"Setting up the sampler","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"import emcee\n\nnwalkers = spnta.ndim * 5\np0 = np.array([spnta.prior_transform(cube) for cube in np.random.rand(nwalkers, spnta.ndim)])\n\nsampler = emcee.EnsembleSampler(\n    nwalkers,\n    spnta.ndim,\n    spnta.lnpost_vectorized,\n    moves=[emcee.moves.StretchMove(), emcee.moves.DESnookerMove()],\n    vectorize=True,\n)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"p0 contains a number of random draws from the prior distribution. Note the vectorize=True while creating the sampler. This should be given if we are using the vectorized log-posterior.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"In practice, the moves should be optimized based on the problem at hand.","category":"page"},{"location":"pyvela/#Running-MCMC","page":"Getting started: The pyvela interface","title":"Running MCMC","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"sampler.run_mcmc(p0, 6000, progress=True)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"This will only take a few seconds because the dataset is very small. Larger datasets may take minutes or hours depending on the size and the computing power available.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"samples_v_0 = sampler.get_chain(flat=True, discard=1000, thin=50)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"This flattens the multiple chains emcee was running. Also note the burn-in (discard)  and the thinning.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"samples_v = spnta.rescale_samples(samples_v_0)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"This converts the samples into the usual units used in pulsar astronomy.","category":"page"},{"location":"pyvela/#Printing-out-the-results","page":"Getting started: The pyvela interface","title":"Printing out the results","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"means = np.mean(samples_v, axis=0)\nstds = np.std(samples_v, axis=0)\nfor idx, (pname, mean, std) in enumerate(zip(spnta.param_names, means, stds)):\n    if pname == \"F0\":\n        F0_ = np.longdouble(spnta.model.param_handler._default_params_tuple.F_.x)\n        print(f\"{pname}\\t\\t{mean + F0_}\\t\\t{std}\")    \n    else:\n        print(f\"{pname}\\t\\t{mean}\\t\\t{std}\")","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Recall that the F0 value is stored as a sum of two Float64s. The special case in the if block combines these parts back together.","category":"page"},{"location":"pyvela/#Plotting","page":"Getting started: The pyvela interface","title":"Plotting","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"import corner\nimport matplotlib.pyplot as plt\n\nfig = corner.corner(\n    samples_v,\n    labels=spnta.param_labels,\n    label_kwargs={\"fontsize\": 11},\n    range=[0.999] * spnta.ndim,\n    plot_datapoints=False,\n    hist_kwargs={\"density\": True},\n    labelpad=0.3,\n)\nplt.suptitle(spnta.model.pulsar_name)\nplt.tight_layout()\nplt.show()","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The output looks something like this: (Image: NGC6440E_posterior)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Note that the F0 plot is centered around 0. This is because F0 is split into  the sum of a large number and a small number to have more numerical precision,  and only the smaller part is treated as a free parameter. See Quantities for more details.","category":"page"},{"location":"priors/#Prior-and-Posterior-distributions","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The prior distributions of each free parameter is represented as a Prior object.   These use the Distributions defined by Distributions.jl  under the hood. ","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Prior","category":"page"},{"location":"priors/#Vela.Prior","page":"Prior and Posterior distributions","title":"Vela.Prior","text":"Abstract base class of all priors.\n\n\n\n\n\n","category":"type"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The priors corresponding to Parameters and MultiParameters are represented by two subtypes of Prior.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(Prior)))","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"SimplePrior\nSimplePriorMulti","category":"page"},{"location":"priors/#Vela.SimplePrior","page":"Prior and Posterior distributions","title":"Vela.SimplePrior","text":"SimplePrior{name,D<:Distribution}\n\nA univariate prior for a single Parameter.\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.SimplePriorMulti","page":"Prior and Posterior distributions","title":"Vela.SimplePriorMulti","text":"SimplePriorMulti{name,index,D<:Distribution}\n\nA univariate prior for a single parameter belonging to a MultiParameter.\n\n\n\n\n\n","category":"type"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Each Prior has lnprior and prior_transform methods which compute  the log-prior distribution  and the prior transform function respectively for that parameter. The former is necessary for MCMC samplers and the latter for nested samplers. Please note that these functions act on Float64s rather than GQs because the samplers  only provide Float64s. A TimingModel also has the lnprior and prior_transform methods; they evaluate  the joint log-prior and the prior transform over all free parameters. The get_lnprior_func and get_prior_transform_func functions return callables that can be passed on to samplers.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"lnprior\nprior_transform\nget_lnprior_func\nget_prior_transform_func","category":"page"},{"location":"priors/#Vela.lnprior","page":"Prior and Posterior distributions","title":"Vela.lnprior","text":"Evaluate the log-prior.\n\n\n\n\n\n","category":"function"},{"location":"priors/#Vela.prior_transform","page":"Prior and Posterior distributions","title":"Vela.prior_transform","text":"Evaluate the prior transform function.\n\n\n\n\n\n","category":"function"},{"location":"priors/#Vela.get_lnprior_func","page":"Prior and Posterior distributions","title":"Vela.get_lnprior_func","text":"get_lnprior_func(::TimingModel)::Function\n\nReturns a callable that evaluates the log-prior given a collection of parameter values.\n\n\n\n\n\n","category":"function"},{"location":"priors/#Vela.get_prior_transform_func","page":"Prior and Posterior distributions","title":"Vela.get_prior_transform_func","text":"get_prior_transform_func(::TimingModel)::Function\n\nReturns a callable that evaluates the prior transform given a point within a unit hypercube.\n\n\n\n\n\n","category":"function"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The log-posterior is the sum of the log-likelihood and the log-prior up to an additive  constant. The get_lnpost_func function returns a callable that evaluates the log-posterior  can be passed on to samplers. Note that the expensive log-likelihood is evaluated only if the  log-prior is finite. ","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"get_lnpost_func","category":"page"},{"location":"priors/#Vela.get_lnpost_func","page":"Prior and Posterior distributions","title":"Vela.get_lnpost_func","text":"get_lnpost_func(::TimingModel, toas::Vector{T}, vectorize::Bool = false) where {T<:TOABase}\n\nReturns a callable that evaluates the log-posterior given a collection of parameter values. If vectorize is true, then the function supports parallel evaluation on different points in the parameter space. \n\n\n\n\n\n","category":"function"},{"location":"priors/#Priors-for-different-parameters","page":"Prior and Posterior distributions","title":"Priors for different parameters","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"In principle, the prior for each parameter has to be set based on our prior knowledge. Indeed, we may have prior information on some of the parameters from previous timing experiments, VLBI  campaigns, detection of counterparts in other parts of the electromagnetic spectrum (e.g., using GAIA), etc. Or priors may be estimated from population statistics using something like  psrcat.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"However, for many parameters, pulsar timing provides so much signal-to-noise ratio that the effect of the prior on the posterior distrubution is entirely negligible. This is the case for parameters like F0, F1, RAJ, DECJ, etc. In such a case, it may be enough to use \"cheat\" priors that are based on the frequentist uncertainties for these parameters (given in the par file). Specifically, we use uniform distributions centered around the frequentist estimate whose width is several times (e.g., 10x) the frequentist uncertainty. Care must be taken to ensure that the data provides enough S/N for the parameter for the \"cheat\" prior to be valid, otherwise we will be effectively  double dipping.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"For some parameters, e.g., the orbital inclination, we have physically motivated default prior distributions.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"KINPriorDistribution\nSINIPriorDistribution\nSTIGMAPriorDistribution\nSHAPMAXPriorDistribution","category":"page"},{"location":"priors/#Vela.KINPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.KINPriorDistribution","text":"KINPriorDistribution\n\nDistribution of KIN = ι when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.SINIPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.SINIPriorDistribution","text":"SINIPriorDistribution\n\nDistribution of SINI = sin(ι) when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.STIGMAPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.STIGMAPriorDistribution","text":"STIGMAPriorDistribution\n\nDistribution of STIGMA = sin(ι)/(1 + cos(ι)) when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.SHAPMAXPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.SHAPMAXPriorDistribution","text":"SHAPMAXPriorDistribution\n\nDistribution of SHAPMAX = -ln(1 - sin(ι)) when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The preference for the prior distributions is user defined distribution > default distribution > \"cheat\" distribution. Please take care to ensure that the wrong parameter doesn't end up with a \"cheat\" distribution.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"See the documentation for Distrubutions.jl to see what distributions are available.","category":"page"},{"location":"priors/#Representing-priors-in-a-JSON-file","page":"Prior and Posterior distributions","title":"Representing priors in a JSON file","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Prior distributions available in Distributions.jl can be represented as a JSON file like so:","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"{\n    \"EFAC\": {\n        \"distribution\": \"LogNormal\",\n        \"args\": [0.0, 0.5]\n    },\n    \"EQUAD\": {\n        \"distribution\": \"LogUniform\",\n        \"args\": [1e-8, 1e-6]\n    }\n    \"M2\": {\n        \"distribution\": \"Normal\",\n        \"args\": [492.7, 98.5],\n        \"lower\": 0.0\n    }\n}","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The distribution attribute for each parameter corresponds to a UnivariateDistribution available in Distributions.jl (see here). args are arguments to the  UnivariateDistribution type's constructor. The lower and upper attributes represent the lower and  upper bounds for truncating the distribution (see truncated).","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Note that the values above should be given Vela.jl's internal units. Specifically, the prior on M2 corresponds  to 0.1 ± 0.02 Msun, where the normal distribution is truncated at a lower bound 0.","category":"page"},{"location":"likelihood/#The-Likelihood-Function-and-Kernels","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"","category":"section"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The pulsar timing log-likelihood function is given by ","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"ln L = -frac12r^T C^-1 r - frac12ln det C","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"where C is the covariance matrix that is represented by a Kernel, incorporating the measurement  uncertainties and the various correlated noise processes.","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The calc_lnlike and calc_lnlike_serial functions compute this log-likelihood function. The difference between them is that the former parallelizes the computation using threads over TOAs whereas the latter  executes serially. ","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"calc_lnlike\ncalc_lnlike_serial","category":"page"},{"location":"likelihood/#Vela.calc_lnlike","page":"The Likelihood Function and Kernels","title":"Vela.calc_lnlike","text":"calc_lnlike(::TimingModel, ::Vector{T}, params)::Float64 where {T<:TOABase}\n\nCompute the log-likelihood value for a given timing model and collection of TOAs  (parallel execution).\n\nReference:     Lentati+ 2014\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Vela.calc_lnlike_serial","page":"The Likelihood Function and Kernels","title":"Vela.calc_lnlike_serial","text":"calc_lnlike_serial(::TimingModel, ::Vector{T}, params)::Float64 where {T<:TOABase}\n\nCompute the log-likelihood value for a given timing model and collection of TOAs  (serial execution).\n\nReference:     Lentati+ 2014\n\n\n\n\n\n","category":"function"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The get_lnlike_func function return a callable that can be passed on to sampling packages. It chooses parallel or serial execution based on the number of available threads. It also has a vectorize option that evaluates the likelihood function over multiple sets of parameters parallely. This is supported by some samplers like emcee, and is more efficient than parallelizing over TOAs. There is also a get_lnlike_serial_func function that always returns the serial version of the callable.","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"get_lnlike_func\nget_lnlike_serial_func","category":"page"},{"location":"likelihood/#Vela.get_lnlike_func","page":"The Likelihood Function and Kernels","title":"Vela.get_lnlike_func","text":"get_lnlike_func(model, toas)::Function\n\nGet the log_likelihood(params) function for a given timing model and collection of TOAs. Serial or parallel execution is decided based on the number of available threads.\n\nSupports both narrowband and wideband TOAs.\n\nUse get_lnlike_serial_func(model, toas) to force serial execution of the likelihood.  The serial version should be used if parallelization is to be implemented at a different level  (e.g., within the sampling method).\n\nReference:     Lentati+ 2014,     Alam+ 2021,     Johnson+ 2024\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Vela.get_lnlike_serial_func","page":"The Likelihood Function and Kernels","title":"Vela.get_lnlike_serial_func","text":"get_lnlike_serial_func(model, toas)::Function\n\nVersion of get_lnlike_func that always does serial execution.\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Kernels","page":"The Likelihood Function and Kernels","title":"Kernels","text":"","category":"section"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The matrix operations appearing in the likelihood function expression are evaluated with the help of Kernel objects.","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"Kernel","category":"page"},{"location":"likelihood/#Vela.Kernel","page":"The Likelihood Function and Kernels","title":"Vela.Kernel","text":"Kernel\n\nAbstract base class of all likelihood kernels\n\n\n\n\n\n","category":"type"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"Two types of Kernels are currently supported.","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(Kernel)))","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"WhiteNoiseKernel\nEcorrKernel","category":"page"},{"location":"likelihood/#Vela.WhiteNoiseKernel","page":"The Likelihood Function and Kernels","title":"Vela.WhiteNoiseKernel","text":"A kernel representing only uncorrelated noise. The covariance matrix is diagonal.\n\nReference:     Hobbs+ 2006,     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#Vela.EcorrKernel","page":"The Likelihood Function and Kernels","title":"Vela.EcorrKernel","text":"A kernel representing white noise and ECORR. The covariance matrix is block-diagonal.\n\nAssumes that the TOAs are sorted in the correct order.\n\nReference:     Johnson+ 2024\n\n\n\n\n\n","category":"type"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"More complex Kernels supporting more general forms of C (including time-correlated noise) will be  implemented in the future. Currently such processes are treated as Components, e.g., PLRedNoiseGP.","category":"page"},{"location":"#Vela.jl","page":"Home","title":"Vela.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Bayesian pulsar timing and noise analysis package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Vela.jl project aims to develop a fast and simple-to-use framework for doing Bayesian pulsar timing & noise analysis. It currently supports both narrowband and wideband TOAs along  with most commonly used pulsar timing models. It can be used from Julia REPL, scripts, or  notebooks. It can also be used from Python REPL, scripts, and notebooks with the help of the  pint2vela interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Vela.jl is named after the brightest radio pulsar, the Vela pulsar (J0835-4510). Also, Vēḻa (വേള, वेळ, ...) is a word meaning occasion, time, etc. in some Indian languages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is under active development.","category":"page"},{"location":"toas/#Pulse-Times-of-Arrival-(TOAs)","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"","category":"section"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"The TOA is the fundamental measurable quantity in conventional pulsar timing. They are measured my folding the time series observations using a known pulsar ephemeris, and then matching the  resulting integrated pulse profile against a template. This procedure produces a TOA measurement (usually expressed as an MJD measured against the observatory clock) along with an uncertainty which is assumed to be Gaussian. The TOA measurements and uncertainties, along with some metadata  (such as observing frequency, observatory name, observatory reciever and backend information, etc) is saved in a text file known as a tim file. Often, multiple TOAs are measured from the same  observation by splitting it into multiple frequency sub-bands. This is known as narrowband timing.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"Alternatively, we can measure a TOA and a dispersion measure simultaneously from an observation  using the wideband timing method (Pennucci 2019).  This is useful for dealing with frequency-dependent profile evolution more accurately. It also  helps reduce the number of TOAs significantly, thus reducing the computational cost of analyzing  them.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"In Vela.jl, all TOAs are represented by the abstract type TOABase. Narrowband TOAs are represented using the TOA type and wideband TOAs are represented by the WidebandTOA type. The latter is a composition of a TOA object and a DMInfo object that represents a wideband DM measurement.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"TOABase\nTOA\nDMInfo\nWidebandTOA","category":"page"},{"location":"toas/#Vela.TOABase","page":"Pulse Times of Arrival (TOAs)","title":"Vela.TOABase","text":"TOABase\n\nAbstract base type of all TOAs.\n\n\n\n\n\n","category":"type"},{"location":"toas/#Vela.TOA","page":"Pulse Times of Arrival (TOAs)","title":"Vela.TOA","text":"TOA\n\nA single narrowband TOA observation.\n\nvalue is the TOA in the TDB timescale incorporating the clock corrections. ephem contains the solar system ephemerides. These are computed using PINT.\n\nReferences:     Hobbs+ 2006,     Luo+ 2021\n\n\n\n\n\n","category":"type"},{"location":"toas/#Vela.DMInfo","page":"Pulse Times of Arrival (TOAs)","title":"Vela.DMInfo","text":"DMInfo\n\nDM information associated with a wideband TOA.\n\nReferences:     Pennucci+ 2014,     Pennucci 2019\n\n\n\n\n\n","category":"type"},{"location":"toas/#Vela.WidebandTOA","page":"Pulse Times of Arrival (TOAs)","title":"Vela.WidebandTOA","text":"WidebandTOA\n\nA single wideband TOA observation.\n\ntoa.value is the wideband TOA measurement in the TDB frame incorporating the clock  corrections. toa.ephem contains the solar system ephemerides. These are computed using  PINT.\n\nReferences:     Pennucci+ 2014,     Pennucci 2019,     Luo+ 2021\n\n\n\n\n\n","category":"type"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"A TOA object contains the clock-corrected TOA value in the TDB timescale, uncertainty, and  observing frequency, along with the solar system ephemeris evaluated at that instance. The clock corrections from the observatory timescale to TDB and the solar system ephemeris computations are precomputed using PINT, which in turn uses astropy underneath. The solar system ephemerides are represented using the SolarSystemEphemeris type.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"SolarSystemEphemeris","category":"page"},{"location":"toas/#Vela.SolarSystemEphemeris","page":"Pulse Times of Arrival (TOAs)","title":"Vela.SolarSystemEphemeris","text":"SolarSystemEphemeris\n\nStruct containing solar system ephemeris vectors corresponding to a TOA.\n\nThese are computed using PINT, which uses the JPL ephemerides internally.\n\nReferences:     Hobbs+ 2006,     Luo+ 2021\n\n\n\n\n\n","category":"type"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"The TOA objects do not contain any other metadata unlike the PINT TOAs objects or  the tempo2 observation objects. Everything that depend on the metadata are precomputed and  stored elsewhere. This helps with computational efficiency by avoiding repeated string operations.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"A performance-critical assumption made in Vela.jl is that the TOAs are immutable. This assumption  is not possible in general pulsar timing packages such as tempo2 and PINT since they allow interactive removal and flagging of TOAs. Vela.jl does not have this use case since it is only meant to do pulsar timing & noise analysis on TOAs that have already gone through data combination & timing stages.","category":"page"},{"location":"residuals/#Residuals","page":"Residuals","title":"Residuals","text":"","category":"section"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"The timing residual corresponding to a TOA can be computed using the form_residual function. This function also returns the DM residual in the case of wideband data.","category":"page"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"form_residual","category":"page"},{"location":"residuals/#Vela.form_residual","page":"Residuals","title":"Vela.form_residual","text":"form_residual(::TimingModel, ::TOA, params::NamedTuple, tzrphase::GQ)::GQ\n\nCompute the timing residual corresponding to a single narrowband TOA.\n\n\n\n\n\nform_residual(::TimingModel, ::WidebandTOA, params::NamedTuple, tzrphase::GQ)::Tuple{GQ, GQ}\n\nCompute the timing and DM residuals corresponding to a single wideband TOA.\n\n\n\n\n\n","category":"function"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"Under the hood, it calls the correct_toa method for each component, and computes the phase residual, which is the computed phase modulo 1 (this is done using the phase_residual function). The timing residual is the phase residual divided by the topocentric spin frequency (computed using  doppler_shifted_spin_frequency).","category":"page"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"The form_residuals function computes the residuals for a collection of TOAs.","category":"page"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"form_residuals","category":"page"},{"location":"residuals/#Vela.form_residuals","page":"Residuals","title":"Vela.form_residuals","text":"form_residuals(::TimingModel, ::Vector{TOA}, params::NamedTuple)::Vector{GQ}\n\nCompute the timing residuals corresponding to a collection of narrowband TOAs.\n\n\n\n\n\nform_residuals(::TimingModel, ::Vector{WidebandTOA}, params::NamedTuple)::Vector{Tuple{GQ, GQ}}\n\nCompute the timing and DM residuals corresponding to a collection of wideband TOAs.\n\n\n\n\n\n","category":"function"}]
}
