var documenterSearchIndex = {"docs":
[{"location":"precision/#Precision","page":"Precision","title":"Precision","text":"","category":"section"},{"location":"precision/","page":"Precision","title":"Precision","text":"Pulsar timing is one of the most precise techniques in science. This means that we often deal with quantities of immense dynamic range which cannot be represented using double-precision floating point (Float64) numbers. The quantities where more than double precision is necessary include the pulse time of arrivals (TOAs), pulse phases, and pulsar rotational frequencies. ","category":"page"},{"location":"precision/","page":"Precision","title":"Precision","text":"In tempo2 and PINT, these quantities are represented using the long double type available in  C/C++ (PINT uses numpy.longdouble, which uses C long double internally). Unfortunately, sizeof(long double) is not fixed by the C and C++ standards, and in some hardware it can be  the same as the double type (e.g., the Apple Mx machines). In such cases, tempo2 falls back to  the __float128 type which is available as a compiler extension in gcc, whereas PINT  does not work at all (see this page).","category":"page"},{"location":"precision/","page":"Precision","title":"Precision","text":"To avoid this harware dependency, Vela.jl represents these quantities using the Double64 type available in DoubleFloats.jl. This package implements the double-double arithmetic  (Decker 1971) which treats an extended-precision number  as a sum of two Float64s. Further, Double64 is faster than the software-implemented Float128  type from the Quadmath.jl package which uses __float128 under the hood.","category":"page"},{"location":"precision/","page":"Precision","title":"Precision","text":"Please note that although the core of the Vela.jl package should be hardware-independent, its full functionality won't be available in machines where PINT won't work, because it relies on  PINT to do certain one-time computations such as clock corrections.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Vela.jl can be installed directly from GitHub. We recommend installing it within a dedicated  conda environment.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Please note that Vela.jl is only tested against Python 3.12 and Julia 1.10 in Ubuntu at present.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you don't have Julia installed, please install it using juliaup following the instructions found  here.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"warning: Warning\nSome of the dependencies don't work properly if Julia isn't installed using juliaup. Specifically, avoid installing Julia using conda. The following instructions are for installing the Python dependencies only.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Now, install the Python dependencies and set the environment variables. The most important one is PYTHON_JULIACALL_HANDLE_SIGNALS. If it is not set properly you'll get segmentation faults.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(base) $ # Setup conda environment\n(base) $ conda create -n vela python=3.12\n(base) $ conda activate vela\n(vela) $ conda install -c conda-forge pyjuliacall pint-pulsar>=1.1 black emcee nestle corner tqdm pytest pytest-xdist\n(vela) $ conda env config vars set PYTHON_JULIACALL_HANDLE_SIGNALS=yes\n(vela) $ conda env config vars set PYTHON_JULIACALL_THREADS=4\n(vela) $ conda env config vars set JULIA_NUM_THREADS=4\n(vela) $ conda env config vars set JULIA_CONDAPKG_BACKEND=\"Null\"","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The number of threads available to Vela.jl for parallel processing can be controlled  using the environment variables JULIA_NUM_THREADS (for direct use from Julia) or  PYTHON_JULIACALL_THREADS (for use from within Python).","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Now, install the Julia packages.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ julia\njulia> import Pkg\njulia> Pkg.Registry.add(url=\"https://github.com/abhisrkckl/julia_registry\")\njulia> Pkg.add([\"LocalRegistry\", \"JuliaFormatter\", \"BenchmarkTools\", \"PythonCall\", \"Distributions\", \"DoubleFloats\", \"GeometricUnits\"])\njulia> Pkg.add(url=\"https://github.com/abhisrkckl/Vela.jl\")\njulia> exit()","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install the Python interface pyvela.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ pip install git+https://github.com/abhisrkckl/Vela.jl","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The pyvela/examples directory provides several example datasets and scripts. A basic example (using the Python wrapper) can be run like this:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ ./run_example_emcee.py NGC6440E.par NGC6440E.tim","category":"page"},{"location":"installation/#Updating-Vela.jl","page":"Installation","title":"Updating Vela.jl","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To update a Vela.jl installation, do the following.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ julia\njulia> import Pkg\njulia> Pkg.update([\"GeometricUnits\", \"Vela\"])\njulia> exit()","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"To update pyvela, run","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"(vela) $ pip install pyvela --upgrade","category":"page"},{"location":"parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"Each TimingModel has a number of model parameters, some of which are free and some frozen. Some of these parameters are single parameters, like the sky coordinates RAJ and DECJ, and are  represented by the Parameter type. Some come as families of similar parameters, such as the pulsar frequency F0 and its derivatives F1, F2, etc. These are represented as  MultiParameters. These contain information about parameter names, their original units (used by PINT), the scaling factors for converting to and from the Vela.jl units, default values, whether they are free/frozen, etc. ","category":"page"},{"location":"parameters/#Vela.Parameter","page":"Parameters","title":"Vela.Parameter","text":"Parameter\n\nA single model parameter.\n\nCorresponds to floatParameter, AngleParameter, or MJDParameter in PINT.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Vela.MultiParameter","page":"Parameters","title":"Vela.MultiParameter","text":"MultiParameter\n\nA set of model parameters that are characterized by a common name and a varying index.\n\nCorresponds to maskParameter or prefixParameter in PINT.\n\n\n\n\n\n","category":"type"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"The correct_toa methods expect the parameters to be passed in as a NamedTuple containing  GQs for single Parameters and NTuples of GQs for MultiParameters. In general, the  samplers the parameter values input from a sampler will be some type of ordered collection of Float64s like a list, ndarray, Vector, etc. This is converted into a NamedTuple of  appropriate structure by the read_params function. The opposite can be achieved using the read_param_values_to_vector function. The information needed to do these transformations  is stored in the ParamHandler type.","category":"page"},{"location":"parameters/#Vela.ParamHandler","page":"Parameters","title":"Vela.ParamHandler","text":"ParamHandler{PT<:NamedTuple}\n\nHandles the creation of a parameter tuple from a collection of free parameter values.\n\n\n\n\n\n","category":"type"},{"location":"parameters/#Vela.read_params","page":"Parameters","title":"Vela.read_params","text":"read_params(ph::ParamHandler{PT}, free_values)::PT where {PT<:NamedTuple}\n\nCreate a parameter tuple from a collection of free parameter values.\n\nReverse of read_param_values_to_vector().\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.read_param_values_to_vector","page":"Parameters","title":"Vela.read_param_values_to_vector","text":"read_param_values_to_vector(param_handler::ParamHandler, params::NamedTuple)::Vector{Float64}\n\nGenerate a collection of free parameter values from a parameter tuple.\n\nReverse of read_params()\n\n\n\n\n\n","category":"function"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"We also provide utility functions for getting ordered lists of parameter names, prefixes, units, etc.  (in the PINT convention).","category":"page"},{"location":"parameters/#Vela.get_free_param_names","page":"Parameters","title":"Vela.get_free_param_names","text":"get_free_param_names(param_handler::ParamHandler)::Vector{String}\n\nGenerate an ordered collection of free parameter names.\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.get_free_param_prefixes","page":"Parameters","title":"Vela.get_free_param_prefixes","text":"get_free_param_prefixes(param_handler::ParamHandler)::Vector{String}\n\nGenerate an ordered collection of free parameter prefixes.\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.get_free_param_units","page":"Parameters","title":"Vela.get_free_param_units","text":"get_free_param_units(param_handler::ParamHandler)::Vector{String}\n\nGenerate an ordered collection of free parameter units (astropy-compatible).\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.get_free_param_labels","page":"Parameters","title":"Vela.get_free_param_labels","text":"get_free_param_labels(param_handler::ParamHandler; delim::String = \"\n\n\")::Vector{String}\n\nGenerate an ordered collection of free parameter labels.\n\n\n\n\n\n","category":"function"},{"location":"parameters/#Vela.get_scale_factors","page":"Parameters","title":"Vela.get_scale_factors","text":"get_scale_factors(param_handler::ParamHandler)::Vector{Float64}\n\nGet the scale factors that convert the free parameters from Vela.jl's  internal representation to the units used in PINT.\n\n\n\n\n\n","category":"function"},{"location":"parameters/","page":"Parameters","title":"Parameters","text":"A list of parameters and their units can be found here.","category":"page"},{"location":"pyvela-cli/#Command-line-utilities","page":"Command line utilities","title":"Command line utilities","text":"","category":"section"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"The pyvela package included a few command line utilities.","category":"page"},{"location":"pyvela-cli/#pyvela-script","page":"Command line utilities","title":"pyvela script","text":"","category":"section"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"The pyvela script can be used to do simple analysis runs where fine control over data handling,  prior distributions, sampler, etc is not necessary. It has the followingb syntax.","category":"page"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"$ pyvela -h\n\nusage: pyvela [-h] [-J JLSO_FILE] [-P PRIOR_FILE] [-T TRUTH] [-C CHEAT_PRIOR_SCALE] [-o OUTDIR] [-f] [-N NSTEPS] [-b BURNIN] [-t THIN] par_file [tim_file]\n\nA command line interface for the Vela.jl pulsar timing & noise analysis package. Uses emcee for sampling. This may not be appropriate for more complex datasets. Write your own scripts for such cases.\n\npositional arguments:\n  par_file              The pulsar ephemeris file. Should be readable using PINT. The uncertainties listed in the file will be used for 'cheat' priors where applicable.\n  tim_file              The pulsar TOA file. Should be readable using PINT. Either this or a JLSO file (-J) should be provided.\n\noptions:\n  -h, --help            show this help message and exit\n  -J JLSO_FILE, --jlso_file JLSO_FILE\n                        The JLSO file containing pulsar timing and noise model & TOAs created using `pyvela-jlso`. JLSO files may need to be recreated after updating `Vela.jl` since the data format may change. These\n                        files are faster to read and parse.\n  -P PRIOR_FILE, --prior_file PRIOR_FILE\n                        A JSON file containing the prior distributions for each free parameter. (Ignored if `-J` option is used.)\n  -T TRUTH, --truth TRUTH\n                        Pulsar ephemeris file containing the true timing and noise parameter values. Relevant for simulation studies.\n  -C CHEAT_PRIOR_SCALE, --cheat_prior_scale CHEAT_PRIOR_SCALE\n                        The scale factor by which the frequentist uncertainties are multiplied to get the 'cheat' prior distributions.\n  -o OUTDIR, --outdir OUTDIR\n                        The output directory. Will throw an error if it already exists (unless -f is given).\n  -f, --force_rewrite   Force rewrite the output directory if it exists.\n  -N NSTEPS, --nsteps NSTEPS\n                        Number of ensemble MCMC iterations\n  -b BURNIN, --burnin BURNIN\n                        Burn-in length for MCMC chains\n  -t THIN, --thin THIN  Thinning factor for MCMC chains","category":"page"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"This command created saves the MCMC chain and related metadata into an output directory. This includes the following files. The parameter order in all of these files is the same.","category":"page"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"summary.json : A JSON file containing information about the inputs and the system environment. Useful for debugging.\nThe input par and tim files\nThe \"truth\" par file (optional, only relevant for simulations)\nsamples.npy : The numpy format file containing the flattened and burned-in MCMC chain. This can be read using numpy.load().\nsamples_raw.npy : Same as samples.npy, but the quantities here are in Vela.jl's internal units.\nparam_names.txt : An ordered list of free model parameter names following the PINT conventions.\nparam_prefixes.txt : An ordered list of free model parameter prefixes following the PINT conventions.\nparam_scale_factors.txt : An ordered list of scale factors which convert parameter values from PINT units to Vela.jl's internal units. The values in samples.npy and samples_raw.npy are related by these scale factors.\nparams_maxpost.txt : Maximum-posterior sample found in the MCMC chain (May not be the same as the mode of the posterior distribution)\nparams_median.txt : The posterior median sample estimated from the MCMC chain\nparam_units.txt : Parameter units represented as astropy.units-compatible strings. Empty rows represent dimensionless quantities.\nparam_default_values.txt : \"Pre-fit\" values taken from the input par file.\n<PSR>.maxpost.par : A \"post-fit\" par file containing the maximum-posterior values taken from the MCMC chain.\n<PSR>.median.par : A \"post-fit\" par file containing the posterior median values taken from the MCMC chain.\nresiduals.txt : Post-fit residuals computed using the posterior median values","category":"page"},{"location":"pyvela-cli/#pyvela-plot-script","page":"Command line utilities","title":"pyvela-plot script","text":"","category":"section"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"Creates a corner plot from a directory containing the output of the pyvela script. The plots are not publication-quality.","category":"page"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"$ pyvela-plot -h\n\nusage: pyvela-plot [-h] [-I IGNORE_PARAMS [IGNORE_PARAMS ...]] result_dir\n\nCreate a corner plot from pyvela results.\n\npositional arguments:\n  result_dir            A directory containing the output of the `pyvela` script.\n\noptions:\n  -h, --help            show this help message and exit\n  -I IGNORE_PARAMS [IGNORE_PARAMS ...], --ignore_params IGNORE_PARAMS [IGNORE_PARAMS ...]\n                        Parameters to exclude from the corner plot.","category":"page"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"The output looks like this: (Image: pyvela_plot_output)","category":"page"},{"location":"pyvela-cli/#pyvela-jlso-script","page":"Command line utilities","title":"pyvela-jlso script","text":"","category":"section"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"Creates a JLSO file that is a serialization of the Vela.TimingModel and Vector{Vela.TOA} objects from a pair of par and tim files and optionally a prior file. This is useful for reducing the input reading overhead while running repeated analyses on the same input files. The resulting JLSO file can be passed on to the pyvela script through the -J option.","category":"page"},{"location":"pyvela-cli/","page":"Command line utilities","title":"Command line utilities","text":"$ pyvela-jlso -h\n\nusage: pyvela-jlso [-h] [-P PRIOR_FILE] [-C CHEAT_PRIOR_SCALE] -o OUTFILE par_file tim_file\n\nRead a par file, tim file, and prior JSON file, and write a JLSO file.\n\npositional arguments:\n  par_file              The pulsar ephemeris file. Should be readable using PINT. The uncertainties listed in the file will be used for 'cheat' priors where applicable.\n  tim_file              The pulsar TOA file. Should be readable using PINT.\n\noptions:\n  -h, --help            show this help message and exit\n  -P PRIOR_FILE, --prior_file PRIOR_FILE\n                        A JSON file containing the prior distributions for each free parameter.\n  -C CHEAT_PRIOR_SCALE, --cheat_prior_scale CHEAT_PRIOR_SCALE\n                        The scale factor by which the frequentist uncertainties are multiplied to get the 'cheat' prior distributions.\n  -o OUTFILE, --outfile OUTFILE\n                        The output file name. Will replace an existing file.","category":"page"},{"location":"vela-fitter/#VelaFitter","page":"VelaFitter","title":"VelaFitter","text":"","category":"section"},{"location":"vela-fitter/","page":"VelaFitter","title":"VelaFitter","text":"VelaFitter is an implementation of the PINT Fitter interface using Vela.jl as a backend. This is a thin wrapper over the pyvela.SPNTA class. It can be used like  any other PINT Fitter for both narrowband and wideband TOAs. The fitting is done  by sampling the posterior distribution using emcee. ","category":"page"},{"location":"vela-fitter/","page":"VelaFitter","title":"VelaFitter","text":"Unlike other Fitters, the toas object herein is immutable, and changing its contents  will not make any difference in the fitting.","category":"page"},{"location":"vela-fitter/","page":"VelaFitter","title":"VelaFitter","text":"An example is given below.","category":"page"},{"location":"vela-fitter/","page":"VelaFitter","title":"VelaFitter","text":"from pint.models import get_model_and_toa\nfrom pyvela.fitter import VelaFitter\n\nmodel, toas = get_model_and_toas(\"NGC6440E.par\", \"NGC6440E.tim\")\n\nftr = VelaFitter(\n    toas, \n    model, \n    custom_priors={\n        \"EQUAD\": {\n            \"distribution\": \"LogUniform\", \n            \"args\": [1e-3, 2.0]\n        }\n    }\n)\n\nftr.fit_toas()\n\nprint(ftr.model)","category":"page"},{"location":"quantities/#Quantities","page":"Quantities","title":"Quantities","text":"","category":"section"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"It turns out that we can write the entire pulsar timing formula (e.g., see Equations 1-2 of  Susobhanan+ 2024) can be expressed such that all quantities appearing therein have dimensions of the form [T^n]. In practice, this is achieved by absorbing certain constants appearing in the timing formula into measurable quantities.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"For example, DM -> DMconst*DM; M2 -> G*M2/c^3; PX -> PX*c/AU; etc.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"This means that we can represent all quantities in pulsar timing in the form x*s^p after some scaling, where x is the value of the scaled quantity in SI units, s is second, and p is an integer. This is implemented in the GeometricUnits.jl package as the GQ{p,F<:AbstractFloat} type (with p ∈ Integer). This package overloads all the arithmetic and comparison operators as well as elementary mathematical functions for the GQ type. i.e., GQ types can be used just like Numbers in most places through the magic of mutiple dispatch.  (GQs do not behave identically to Numbers in some contexts, so GQ is not a subtype of Number.) It also defines iterators and such for the GQ type so that we can use it with packages like LinearAlgebra.jl","category":"page"},{"location":"quantities/#GeometricUnits.GQ","page":"Quantities","title":"GeometricUnits.GQ","text":"GQ{d,X<:AbstractFloat}\n\nRepresents a quantity with dimensions T^d. A GQ can be represented mathematically as x s^d where d  ℤ.\n\n\n\n\n\n","category":"type"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"Note that the dimensionality p is a type parameter, which means that the dimensional correctness will be enforced by the Julia language at \"compile time\", and it will refuse to execute dimensionally  incorrect expressions. This provides strong assurances for code correctness. Further, since p is  a type parameter, there is no run time penalty for ensuring dimensional correctness.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"GeometricUnits.jl also implements the following operations.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"Unary + and - operators for all GQ types\nBinary + and - operators for GQ types with like dimensions\n*, / operators for all GQ types\n^ operator for various cases where the output is a valid GQ\nsqrt cbrt, root functions for cases where the output is a valid GQ\n==, !=, <, <=, >, >=, ≈ operators for GQ types with like dimensions\nTrigonometric functions (sin, cos, sincos, tan, csc, sec, cot) for dimensionless inputs\nInverse trigonometric functions (asin, acos, atan, acsc, asec, acot) for dimensionless inputs \natan function for a pair of  GQs types with like dimensions\nexp, exp2, exp10, log, log2, log10 functions for dimensionless inputs\nabs, sign, floor, ceil functions for all GQ types\nisfinite and isnan functions for all GQ types\nzero and oneunit functions for all GQ types\ntaylor_horner and taylor_horner_integral functions","category":"page"},{"location":"timing-model/#The-Timing-and-Noise-Model","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The pulsar timing & noise model (a.k.a. pulsar ephemeris) is a generative mathematical model for the TOA measurements and uncertainties (and the DM measurements & uncertainties in the wideband paradigm). The timing residuals are the differences between measured TOAs and the TOAs predicted by the timing model. See Hobbs+ 2006 and  Edwards+ 2006 for details.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The physical and instrumental effects that affect one TOA at a time are represented as Components, and the effects that are correlated across multiple TOAs are modeled as a Kernel.","category":"page"},{"location":"timing-model/#Vela.Component","page":"The Timing & Noise Model","title":"Vela.Component","text":"Component\n\nAbstract base type of all timing & noise model components which affect one TOA at a time.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Each component has a correct_toa() method which produces a TOA correction.","category":"page"},{"location":"timing-model/#Vela.correct_toa","page":"The Timing & Noise Model","title":"Vela.correct_toa","text":"correct_toa(::Component, ::TOABase, ::TOACorrectionBase, ::NamedTuple)\n\nCorrect the TOA using a delay, phase, observing frequency shift, uncertainty scaling, doppler factor, etc.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Kernels will be discussed in its own section.","category":"page"},{"location":"timing-model/#TOA-corrections","page":"The Timing & Noise Model","title":"TOA corrections","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"A TOA correction as mentioned above can be one or more of the following:","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"A delay that modifies the TOA value\nA phase correction that modifies the TOA phase\nA Doppler correction that modifies the observing frequency and the pulsar spin frequency\nAn EFAC or EQUAD that modifies the TOA uncertainty\nA DM correction that modifies the wideband DM measurement\nA DMEFAC or DMEQUAD that modifies the wideband DM uncertainty","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The accumlated TOA corrections are represented by the TOACorrection and WidebandTOACorrection types, which are derived from TOACorrectionBase.","category":"page"},{"location":"timing-model/#Vela.TOACorrectionBase","page":"The Timing & Noise Model","title":"Vela.TOACorrectionBase","text":"TOACorrectionBase\n\nAn abstract base class representing accumulated timing & noise model corrections applied to a TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.TOACorrection","page":"The Timing & Noise Model","title":"Vela.TOACorrection","text":"TOACorrection\n\nThe accumulated timing & noise model corrections applied to a narrowband TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.WidebandTOACorrection","page":"The Timing & Noise Model","title":"Vela.WidebandTOACorrection","text":"WidebandTOACorrection\n\nThe accumulated timing & noise model corrections applied to a wideband TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The following methods extract some of the corrected quantities of interest.","category":"page"},{"location":"timing-model/#Vela.corrected_toa_value","page":"The Timing & Noise Model","title":"Vela.corrected_toa_value","text":"TOA value after delay correction.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.doppler_corrected_observing_frequency","page":"The Timing & Noise Model","title":"Vela.doppler_corrected_observing_frequency","text":"Observing frequency in the barycentric or pulsar frame, depending on the correction level. The observing_frequency is originally in the topocentric frame.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.doppler_shifted_spin_frequency","page":"The Timing & Noise Model","title":"Vela.doppler_shifted_spin_frequency","text":"doppler_shifted_spin_frequency(::TOACorrection)\n\nSpin frequency in topocentric or barycentric frame, depending on the correction level. The spin_frequency is originally in the pulsar frame.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.scaled_toa_error_sqr","page":"The Timing & Noise Model","title":"Vela.scaled_toa_error_sqr","text":"scaled_toa_error_sqr(toa::TOA, toacorr::TOACorrection)\n\nSquared TOA uncertainty after applying EFAC and EQUAD.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.scaled_dm_error_sqr","page":"The Timing & Noise Model","title":"Vela.scaled_dm_error_sqr","text":"scaled_dm_error_sqr(::DMInfo, ::DMInfoCorrection)\n\nSquared DM uncertainty after applying DMEFAC and DMEQUAD.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.phase_residual","page":"The Timing & Noise Model","title":"Vela.phase_residual","text":"phase_residual(::TOA, ::TOACorrection)\n\nTOA phase residual\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.dm_residual","page":"The Timing & Noise Model","title":"Vela.dm_residual","text":"dm_residual(::DMInfo, ::DMInfoCorrection)\n\nCompute DM residual corresponding to a wideband TOA.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"There are three types of Components as shown below based on what type of corrections they provide.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(Component, maxdepth=1)))","category":"page"},{"location":"timing-model/#Delay-components","page":"The Timing & Noise Model","title":"Delay components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DelayComponents correct the measured TOA by subtracting certain delays.","category":"page"},{"location":"timing-model/#Vela.DelayComponent","page":"The Timing & Noise Model","title":"Vela.DelayComponent","text":"DelayComponent\n\nAbstract base type of all timing model components which contribute a time delay correction to a TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DelayComponent has further subtypes which represent different physical processes producing delays.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(DelayComponent, maxdepth=1)))","category":"page"},{"location":"timing-model/#Solar-system-delays","page":"The Timing & Noise Model","title":"Solar system delays","text":"","category":"section"},{"location":"timing-model/#Vela.SolarSystem","page":"The Timing & Noise Model","title":"Vela.SolarSystem","text":"Solar system Rømer delay, Parallax delay, and Shapiro delay.\n\nCorresponds to AstrometryEquatorial, AstrometryEcliptic,  and SolarSystemShapiro in PINT.\n\nReference:     Edwards+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"In addition to a delay, SolarSystem also producess a Doppler correction which applies to the observing frequency and the pulsar spin frequency. ","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"This component barycenters the TOA. It will skip TOAs that are already barycentered, e.g., TOAs measured using space-based telescopes. The is_barycentered() function checks whether a TOA has been barycentered.","category":"page"},{"location":"timing-model/#Vela.is_barycentered","page":"The Timing & Noise Model","title":"Vela.is_barycentered","text":"is_barycentered(::TOA)::Bool\n\nChecks if a TOA has been barycentered.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Dispersion-delays","page":"The Timing & Noise Model","title":"Dispersion delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionComponents represent the dispersion of the radio waves due to the free electrons present along the line of sight to the pulsar. This may include the ionized interstellar medium as well as  solar wind.","category":"page"},{"location":"timing-model/#Vela.DispersionComponent","page":"The Timing & Noise Model","title":"Vela.DispersionComponent","text":"DispersionComponent\n\nAbstrct base type of all timing model components which provide a dispersion measure correction.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionComponents provide a delay and a DM correction (for wideband TOAs), which are related by the equation Delta_textDM = K * textDM  nu^2. The dispersion correction is computed via  the dispersion_slope() function.","category":"page"},{"location":"timing-model/#Vela.dispersion_slope","page":"The Timing & Noise Model","title":"Vela.dispersion_slope","text":"dispersion_slope(::DispersionComponent, ::TOA, ::TOACorrection, ::NamedTuple)\n\nCompute the dispersion slope corresponding to a TOA. \n\n\n\n\n\n","category":"function"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The DispersionComponents available in Vela.jl are","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(DispersionComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The most basic DispersionComponent is DispersionTaylor.","category":"page"},{"location":"timing-model/#Vela.DispersionTaylor","page":"The Timing & Noise Model","title":"Vela.DispersionTaylor","text":"DispersionTaylor\n\nTaylor series representation of the dispersion measure.\n\nCorresponds to DispersionDM in PINT.\n\nReference:     Backer & Hellings 1986\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DMWaveX and PowerlawDispersionNoiseGP provide two representations of the dispersion noise / stochastic DM variations.","category":"page"},{"location":"timing-model/#Vela.DMWaveX","page":"The Timing & Noise Model","title":"Vela.DMWaveX","text":"DMWaveX\n\nAn unconstrained Fourier series representation of the dispersion noise. Corresponds to the DMWaveX component in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PowerlawDispersionNoiseGP","page":"The Timing & Noise Model","title":"Vela.PowerlawDispersionNoiseGP","text":"PowerlawDispersionNoiseGP\n\nA Fourier series Gaussian process representation of the dispersion noise where the  power spectral density is assumed to be a power law. Corresponds to PLDMNoise in PINT.\n\nReference:     Lentati+ 2014,     van Haasteren & Vallisneri 2014\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"See also Red noise models.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"SolarWindDispersion is a simple model for solar wind dispersion.","category":"page"},{"location":"timing-model/#Vela.SolarWindDispersion","page":"The Timing & Noise Model","title":"Vela.SolarWindDispersion","text":"SolarWindDispersion\n\nSolar wind model assuming a spherically symmetric distribution of electrons which falls off as an inverse-square function of the distance from the Sun. Corresponds to the SolarWindDispersion model in PINT.\n\nReference:     Edwards+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Alternatively, DM variations can be modeled as a simple piecewise-constant function using DMX parameters. This is available through the DispersionPiecewise component.","category":"page"},{"location":"timing-model/#Vela.DispersionPiecewise","page":"The Timing & Noise Model","title":"Vela.DispersionPiecewise","text":"DispersionPiecewise\n\nPiecewise-constant representation of the dispersion measure.\n\nCorresponds to DispersionDMX in PINT. Overlapping DMX ranges are not supported.\n\nReference:     Arzoumanian+ 2015\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"DispersionJump and DispersionOffset represent two types of system-dependent dispersion  offsets.","category":"page"},{"location":"timing-model/#Vela.DispersionOffset","page":"The Timing & Noise Model","title":"Vela.DispersionOffset","text":"DispersionOffset\n\nSystem-dependent DM offsets (FDJUMPDM) with non-exclusive selection masks. Corresponds to FDJumpDM in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.DispersionJump","page":"The Timing & Noise Model","title":"Vela.DispersionJump","text":"DispersionJump\n\nSystem-dependent wideband DM offsets (DMJUMP) with non-exclusive selection masks.\n\nUnlike an FDJUMPDM, a DMJUMP only provides a DM correction and no delay. Corresponds to DispersionJump in PINT.\n\nReference:     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Chromatic-delays","page":"The Timing & Noise Model","title":"Chromatic delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Chromatic delays are similar to dispersion delays, but have a different powerlaw dependence  on the observing frequency. Such delays can occur due to interstellar scattering or  frequency-dependent dispersion. A chromatic delay is given by Delta_textCM = K * textCM  nu^alpha where CM is called the chromatic measure, and alpha is called the chromatic index. The effect of chromatic effects on wideband TOAs is not well-understood.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(ChromaticComponent)))","category":"page"},{"location":"timing-model/#Vela.ChromaticTaylor","page":"The Timing & Noise Model","title":"Vela.ChromaticTaylor","text":"ChromaticTaylor\n\nTaylor series representation of the chromatic measure.\n\nCorresponds to ChromaticCM in PINT.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.CMWaveX","page":"The Timing & Noise Model","title":"Vela.CMWaveX","text":"CMWaveX\n\nA Fourier series representation of the variable-index chromatic red noise. Corresponds to the CMWaveX component in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PowerlawChromaticNoiseGP","page":"The Timing & Noise Model","title":"Vela.PowerlawChromaticNoiseGP","text":"PowerlawDispersionNoiseGP\n\nA Fourier series Gaussian process representation of the chromatic noise where the  power spectral density is assumed to be a power law. Corresponds to PLChromNoise in PINT.\n\nReference:     Lentati+ 2014,     van Haasteren & Vallisneri 2014\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"See also Red noise models.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Chromatic variations can also be modeled as a simple piecewise-constant function using CMX parameters. This is available through the ChromaticPiecewise component.","category":"page"},{"location":"timing-model/#Vela.ChromaticPiecewise","page":"The Timing & Noise Model","title":"Vela.ChromaticPiecewise","text":"Piecewise-constant representation of the chromatic measure with a  constant chromatic index.\n\nCorresponds to ChromaticCMX in PINT. Does not support overlapping  ranges.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Binary-delays","page":"The Timing & Noise Model","title":"Binary delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Similar to solar system delays, the binary motion of the pulsar also introduces various  delays to the TOAs, including Rømer delay, Shapiro delay, and Einstein delay. ","category":"page"},{"location":"timing-model/#Vela.BinaryComponent","page":"The Timing & Noise Model","title":"Vela.BinaryComponent","text":"BinaryComponent\n\nAbstract base type of all binary components.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Different binary models are used based on the properties of the binary orbit.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(BinaryComponent)))","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Vela.jl has two families of binary models. The ELL1 family is used for nearly circular binaries and the DD family is used for eccentric orbits. The different models are characterized by their treatment of Shapiro delay, Kopeikin corrections, etc.","category":"page"},{"location":"timing-model/#Vela.BinaryDD","page":"The Timing & Noise Model","title":"Vela.BinaryDD","text":"BinaryDD\n\nThe Damour & Deruelle binary model for eccentric binaries.\n\nReference:     Damour & Deruelle 1986\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryDDH","page":"The Timing & Noise Model","title":"Vela.BinaryDDH","text":"BinaryDDH\n\nThe Damour & Deruelle model for eccentric binaries with orthometric parametrization of the Shapiro delay. Used for low to moderate inclination binaries.\n\nReferences:     Damour & Deruelle 1986,      Freire & Wex 2010,     Weisberg & Huang 2016\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryDDK","page":"The Timing & Noise Model","title":"Vela.BinaryDDK","text":"BinaryDDK\n\nThe Damour & Deruelle model for eccentric binaries with Kopeikin corrections included, which account for the apparent changes in the orbital elements due to proper motion and  parallax.\n\nReferences:     Damour & Deruelle 1986,     Kopeikin 1995,     Kopeikin 1996\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryDDS","page":"The Timing & Noise Model","title":"Vela.BinaryDDS","text":"BinaryDDS\n\nThe Damour & Deruelle model for eccentric binaries with an alternative parametrization of Shapiro delay applicable to almost edge-on orbits.\n\nReferences:     Damour & Deruelle 1986,     Kramer+ 2006,     Rafikov & Lai 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryELL1","page":"The Timing & Noise Model","title":"Vela.BinaryELL1","text":"BinaryELL1\n\nA binary model representing a nearly circular orbit.\n\nReference:     Lange+ 2001\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryELL1H","page":"The Timing & Noise Model","title":"Vela.BinaryELL1H","text":"BinaryELL1H\n\nA binary model representing a nearly circular orbit with orthometric  parametrization of the Shapiro delay. The Shapiro delay computed in this model does not include the Fourier components that are fully covariant with the Rømer delay.\n\nReference:     Lange+ 2001,     Freire & Wex 2010\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.BinaryELL1k","page":"The Timing & Noise Model","title":"Vela.BinaryELL1k","text":"BinaryELL1k\n\nA binary model representing a nearly circular orbit with large advance of  periapsis. The difference between this model and ELL1 is that this model features an exact treatment of advance of periapsis whereas ELL1 uses a linear approximation. \n\nReference:     Susobhanan+ 2018\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Frequency-dependent-delays","page":"The Timing & Noise Model","title":"Frequency-dependent delays","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Unmodeled frequency-dependent profile evolution can manifest as frequency-dependent delays in narrowband TOAs. These are taken care during timing using certain phenomenological  models listed below.","category":"page"},{"location":"timing-model/#Vela.FrequencyDependent","page":"The Timing & Noise Model","title":"Vela.FrequencyDependent","text":"FrequencyDependent\n\nA frequency-dependent delay to account for frequency-dependent profile evolution.  Corresponds to FD in PINT.\n\nReference:     Arzoumanian+ 2015\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.FrequencyDependentJump","page":"The Timing & Noise Model","title":"Vela.FrequencyDependentJump","text":"FrequencyDependentJump\n\nA system- & frequency-dependent delay to account for frequency-dependent profile evolution. This is useful while combining TOAs generated by different experiments with different TOA measurement procedures. Corresponds to FDJump in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Spin-noise","page":"The Timing & Noise Model","title":"Spin noise","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Rotational irregularities of the pulsar causes stochastic modulations on the TOAs. We represent these modulations as a Fourier series in time.","category":"page"},{"location":"timing-model/#Vela.WaveX","page":"The Timing & Noise Model","title":"Vela.WaveX","text":"WaveX\n\nAn unconstrained Fourier series representation of the achromatic red noise. Corresponds to the WaveX component in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PowerlawRedNoiseGP","page":"The Timing & Noise Model","title":"Vela.PowerlawRedNoiseGP","text":"PowerlawRedNoiseGP\n\nA Fourier series Gaussian process representation of the achromatic red noise where the  power spectral density is assumed to be a power law. Corresponds to PLRedNoise in  PINT.\n\nReference:     Lentati+ 2014,     van Haasteren & Vallisneri 2014\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"See also Red noise models.","category":"page"},{"location":"timing-model/#Phase-components","page":"The Timing & Noise Model","title":"Phase components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"A PhaseComponent contributes to the phase computation from a delay-corrected TOA.","category":"page"},{"location":"timing-model/#Vela.PhaseComponent","page":"The Timing & Noise Model","title":"Vela.PhaseComponent","text":"PhaseComponent\n\nAbstract base type of all timing model components which contribute a phase correction to a TOA.\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The hierarchy of PhaseComponents is given below.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(PhaseComponent)))","category":"page"},{"location":"timing-model/#Vela.Spindown","page":"The Timing & Noise Model","title":"Vela.Spindown","text":"Spindown\n\nRotation or the pulsar represented as a Taylor series in spin frequency. Corresponds to Spindown in PINT.\n\nReference:     Backer & Hellings 1986\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.Glitch","page":"The Timing & Noise Model","title":"Vela.Glitch","text":"Glitch\n\nGlitches in pulsar rotation. Corresponds to Glitch in PINT.\n\nReference:     Hobbs+ 2006,     Haskell & Melatos 2015\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PhaseOffset","page":"The Timing & Noise Model","title":"Vela.PhaseOffset","text":"Phase offset between measured TOAs and the TZR TOA. Corresponds to PhaseOffset in PINT.\n\nReference:     Susobhanan+ 2024\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.PhaseJump","page":"The Timing & Noise Model","title":"Vela.PhaseJump","text":"PhaseJump\n\nSystem-dependent phase jumps with non-exclusive selection masks.  Corresponds to PhaseJump in PINT.\n\nReference:     Hobbs+ 2006\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#White-noise-components","page":"The Timing & Noise Model","title":"White noise components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"These components modify the TOA or DM uncertainty in some manner.","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(WhiteNoiseComponent)))","category":"page"},{"location":"timing-model/#Vela.MeasurementNoise","page":"The Timing & Noise Model","title":"Vela.MeasurementNoise","text":"MeasurementNoise\n\nModifications to the measured TOA uncertainties:  EFACs (error factors) and EQUADs (errors added in quadrature). Assumes that the EFACs & EQUADs are exclusive. Corresponds to  ScaleToaErrors in PINT.\n\nReference:     Lentati+ 2014\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Vela.DispersionMeasurementNoise","page":"The Timing & Noise Model","title":"Vela.DispersionMeasurementNoise","text":"DispersionMeasurementNoise\n\nModifications to the measured wideband DM uncertainties: DMEFACs and DMEQUADs. Assumes that the DMEFACs & DMEQUADs are exclusive. Corresponds to ScaleDmErrors in PINT.\n\nReference:     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"timing-model/#Order-of-components","page":"The Timing & Noise Model","title":"Order of components","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"It should be noted that the action of different Components do not commute in general. Therefore,  they must be applied in the correct order to get sensible results. The order followed by Vela.jl  is roughly as follows:","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Delay corrections  a. Solar system effects  b. Interstellar medium effects  c. Pulsar binary effects\nPhase computation  a. Pulsar rotational effects\nUncertainty corrections  a. Measurement noise corrections","category":"page"},{"location":"timing-model/#The-TZR-TOA","page":"The Timing & Noise Model","title":"The TZR TOA","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"The pulse phases are measured with respect to a fictitious fiducial TOA called the TZR TOA (TZR  stands for t_zero). This is represented using a TOA object, but is distinguished from physical  TOAs using the  tzr attribute. The make_tzr_toa() function creates a TZR TOA and the is_tzr()  function checks whether a TOA is a TZR TOA. A TZR TOA is always narrowband.","category":"page"},{"location":"timing-model/#Vela.make_tzr_toa","page":"The Timing & Noise Model","title":"Vela.make_tzr_toa","text":"make_tzr_toa(tzrtdb::GQ{Double64}, tzrfreq::GQ{Float64}, tzrephem::SolarSystemEphemeris)::TOA\n\nCreate a TZR TOA object.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#Vela.is_tzr","page":"The Timing & Noise Model","title":"Vela.is_tzr","text":"is_tzr(::TOA)::Bool\n\nChecks if a TOA is a TZR TOA.\n\n\n\n\n\n","category":"function"},{"location":"timing-model/#The-TimingModel-type","page":"The Timing & Noise Model","title":"The TimingModel type","text":"","category":"section"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"A timing & noise model is represented by the TimingModel type. ","category":"page"},{"location":"timing-model/#Vela.TimingModel","page":"The Timing & Noise Model","title":"Vela.TimingModel","text":"TimingModel\n\nThe pulsar timing & noise model. Supports both narrowband and wideband timing. Corresponds to TimingModel in PINT.\n\nReferences:     Edwards+ 2006,     Lentati+ 2014,     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"It has the following contents:","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"Pulsar name (PSR), solar system ephemeris name (EPHEM), name of the TT timescale realization (CLOCK), etc.\nAn ordered collection of Components\nA Kernel\nA TZR TOA\nA ParamHandler containing information about model parameters.\nAn ordered collection of Priors for each free parameter","category":"page"},{"location":"timing-model/","page":"The Timing & Noise Model","title":"The Timing & Noise Model","text":"These are explained in the following sections.","category":"page"},{"location":"red-noise/#Red-noise-models","page":"Red noise models","title":"Red noise models","text":"","category":"section"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"A time-correlated stochastic process whose power spectral density is a decreasing function of the conjugate frequency (not to be confused with observing frequency) is known as red noise. Depending on the pulsar, different types of red noise processes will be present in the TOAs, including spin noise, dispersion noise, and the stochastic gravitational wave background.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Such a process is usually modeled as truncated Fourier series.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Delta(t) = (fracnu_textrefnu)^alpha sum_j=1^N  a_jcos(2pi j f_1(t-t_0)) + b_jsin(2pi j f_1(t-t_0)) ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"where nu is the observing frequency, nu_textref is a reference frequency, alpha is the chromatic index, N is the number of harmonics, f_1 is the fundamental frequency, t_0 is a fiducial  time, and a_j and b_j are Fourier coefficients.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Two types of red noise models are currently available in Vela.jl. ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"The WaveX family of models treat the Fourier coefficients as unconstrained free parameters  (e.g., WXSIN_ and WXCOS_).","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"The PowerlawRedNoiseGP family of models treat these coefficients as Gaussian random variables whose variances, interpreted as power spectral densities, follow a power law spectrum.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlangle a_j rightrangle = leftlangle b_j rightrangle = 0","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlangle a_j a_k rightrangle = leftlangle b_j b_k rightrangle = sigma_j^2 delta_jk","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlangle a_j b_k rightrangle = 0","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"sigma_j = P(f_j) = fracA^212pi^2 f_textyr^3 f_1 left(fracf_textyrfright)^gamma","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"where A is the powerlaw amplitude gamma is the powerlaw index, and f_textyr=1 textyr^-1. The prior parameters A and gamma are also treated as free parameters and sampled over. However, in this case, the geometry of the parameter space exhibits Neil's funnel-like geometry, which is hard for MCMC samplers to deal with. To avoid this, we use bara_j=a_jsigma_j and  barb_j=b_jsigma_j as free parameters where ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"leftlanglebara_j^2rightrangle = leftlanglebarb_j^2rightrangle = 1","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"In PowerlawRedNoiseGP, this is represented by the parameters PLREDSIN_ and PLREDCOS_. The powerlaw parameters are PLREDAMP and PNREDGAM. Please note that the PINT-format par files do not support PLREDSIN_ and PLREDCOS_. Hence, while they are included in the posterior samples, they will not be included in the output par file.  ","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Similar representations also exist for dispersion noise (alpha=2) and chromatic noise (see Dispersion delays and Chromatic delays).","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"Other types of spectral models such as free spectrum, t-process, broken powerlaw, running power law, etc are not yet implemented.","category":"page"},{"location":"red-noise/","page":"Red noise models","title":"Red noise models","text":"By default, the noise amplitudes described above are treated as free parameters are sampled. However, this can sometimes lead to inefficient sampling due to Neil's funnel effect. One way of avoiding this is to analytically marginalize the posterior distribution over the noise amplitudes. This can be achieved in Vela.jl by moving the Gaussian noise components (PowerlawRedNoiseGP, PowerlawDispersionNoiseGP,  PowerlawChromaticNoiseGP) from the TimingModel components tuple into a WoodburyKernel. The is_gp_noise() function identifies the components that support this operation.","category":"page"},{"location":"red-noise/#Vela.is_gp_noise","page":"Red noise models","title":"Vela.is_gp_noise","text":"is_gp_noise(::Component)::Bool\n\nWhether a component represents a correlated Gaussian noise process.\n\n\n\n\n\n","category":"function"},{"location":"issues/#Known-issues","page":"Known issues","title":"Known issues","text":"","category":"section"},{"location":"issues/#Python-multiprocessing-and-MPI","page":"Known issues","title":"Python multiprocessing and MPI","text":"","category":"section"},{"location":"issues/","page":"Known issues","title":"Known issues","text":"I have noticed segmentation faults while using pyvela with Python multiprocessing and/or MPI even with Julia multithreading turned off. So parallelism doesn't work outside Julia.","category":"page"},{"location":"pyvela/#Getting-started:-The-pyvela-interface","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Vela.jl must interact with Python for three reasons: (1) most pulsar astronomers are more  familiar with Python than Julia (2) Python has many samplers that have no counterpart in  Julia, and most importantly, (3) it is a real pain to implement par and tim file readers. The pyvela interface allows one to access Vela.jl from Python. This is the simplest way to get started with Vela.jl.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The pyvela interface is demonstrated below using an example with the emcee sampler.","category":"page"},{"location":"pyvela/#Reading-par-and-tim-files-using-the-SPNTA-class","page":"Getting started: The pyvela interface","title":"Reading par and tim files using the SPNTA class","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"A pulsar timing dataset usually contains a par file and a tim file. The tim file contains the pulse time of arrival (TOA) measurements and related metadata, and the par file contains a timing & noise model that fits the TOAs along with its parameter values. pyvela reads these files with the  help of the PINT package. PINT also does the clock  corrections and solar system ephemeris calculations. See this page for detailed explanations on these topics.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Here is how we read read a pair of par and tim files in pyvela:","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"from pyvela import SPNTA, Vela\nimport numpy as np\n\nparfile, timfile = \"NGC6440E.par\", \"NGC6440E.tim\"\nspnta = SPNTA(\n    parfile, \n    timfile,\n    cheat_prior_scale=100,\n    custom_priors=None,\n)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Here, spnta.model is a Vela.TimingModel object and spnta.toas is a Vector{Vela.TOA} object.  The SPNTA class reads the par and tim files using the pint.models.get_model_and_toas() function under the hood and converts the resulting pint.models.TimingModel and pint.toa.TOAs objects into the corresponding Vela.jl objects. Note that this conversion does not preserve all the information present in the PINT objects, and is not reversible.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The SPNTA class internally uses the Vela.Pulsar type to store the timing model and the TOAs together. Currently it is assumed that all the TOAs are of the same paradigm (narrowband or wideband). Inhomogeneous datasets are not supported.","category":"page"},{"location":"pyvela/#Vela.Pulsar","page":"Getting started: The pyvela interface","title":"Vela.Pulsar","text":"Pulsar{M<:TimingModel,T<:TOABase}\n\nRepresents a pulsar dataset with a timing model and a set of TOAs. All TOAs must be of the same paradigm (narrowband/wideband).\n\n\n\n\n\n","category":"type"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The cheat_prior_scale and custom_priors arguments are used for specifying the prior distributions for model parameters. See See Representing priors in a JSON file for more details.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Everything defined in Vela.jl will be available through the Vela namespace above, e.g., Vela.TimingModel  and Vela.TOA. Things that were explicitly imported into Vela.jl are also available, e.g., Vela.GQ is the GQ type  from GeometricUnits.jl (see Quantities). Other things from Julia are accessed using the  juliacall package.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The SPNTA object created above provides functions like lnlike(), lnprior(), prior_transform(), lnpost(), and  lnpost_vectorized(). These provide the log-likelihood, log-prior, prior transform, and log-posterior  functions which call Vela.jl under the hood. The difference between spnta.lnpost and  spnta.lnpost_vectorized is that if multiple threads are allowed (by setting the PYTHON_JULIACALL_THREADS environment variable), spnta.lnpost parallelizes a single log-posterior computation across TOAs, whereas spnta.lnpost_vectorized computes the log-posterior at multiple points in the parameter space parallelly. The latter can be used with samplers such as emcee and zeus. Make sure not to set PYTHON_JULIACALL_THREADS  to a value greater than the number of available CPU cores.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The SPNTA object also has useful attributes such as the number of free parameters (ndim), free parameter names (param_names), free parameter labels including units (param_labels), scale factors for converting to and from the Vela.jl internal units (scale_factors), and the default parameters read from the par file (default_params). The rescale_samples() function rescales the samples from Vela.jl internal units to the usual units used in pulsar astronomy (see this page). ","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Now, let us see if lnpost actually works.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"print(spnta.lnpost(spnta.default_params))","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Similarly,","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"print(\n    spnta.lnpost_vectorized(\n        np.array([spnta.default_params])\n    )\n)","category":"page"},{"location":"pyvela/#Setting-up-the-sampler","page":"Getting started: The pyvela interface","title":"Setting up the sampler","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"We show below an example using the emcee sampler.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"import emcee\n\nnwalkers = spnta.ndim * 5\np0 = np.array([spnta.prior_transform(cube) for cube in np.random.rand(nwalkers, spnta.ndim)])\n\nsampler = emcee.EnsembleSampler(\n    nwalkers,\n    spnta.ndim,\n    spnta.lnpost_vectorized,\n    moves=[emcee.moves.StretchMove(), emcee.moves.DESnookerMove()],\n    vectorize=True,\n)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"p0 contains random draws from the prior distribution (see this page for an explanation on how this works). Note the vectorize=True while creating the sampler. This must be given if we are using the  vectorized log-posterior. In practice, the moves should be optimized based on the problem at hand.","category":"page"},{"location":"pyvela/#Running-MCMC-and-getting-the-samples","page":"Getting started: The pyvela interface","title":"Running MCMC and getting the samples","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"sampler.run_mcmc(p0, 6000, progress=True)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"This will only take a few seconds because the dataset is very small. Larger datasets may take minutes or hours depending on the size and the computing power available.","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"samples_raw = sampler.get_chain(flat=True, discard=1000, thin=50)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"This flattens the multiple chains emcee was running. Also note the burn-in (discard)  and the thinning. These samples are in Vela.jl's internal units (see Quantities).","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"samples = spnta.rescale_samples(samples_raw)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"This converts the samples into the usual units used in pulsar astronomy.","category":"page"},{"location":"pyvela/#Printing-out-the-results","page":"Getting started: The pyvela interface","title":"Printing out the results","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"means = np.mean(samples_v, axis=0)\nstds = np.std(samples_v, axis=0)\nfor idx, (pname, mean, std) in enumerate(zip(spnta.param_names, means, stds)):\n    if pname == \"F0\":\n        F0_ = np.longdouble(spnta.model.param_handler._default_params_tuple.F_.x)\n        print(f\"{pname}\\t\\t{mean + F0_}\\t\\t{std}\")    \n    else:\n        print(f\"{pname}\\t\\t{mean}\\t\\t{std}\")","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The special treatment for F0 is explained in Precision.","category":"page"},{"location":"pyvela/#Plotting","page":"Getting started: The pyvela interface","title":"Plotting","text":"","category":"section"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"import corner\nimport matplotlib.pyplot as plt\n\nfig = corner.corner(\n    samples_v,\n    labels=spnta.param_labels,\n    label_kwargs={\"fontsize\": 11},\n    range=[0.999] * spnta.ndim,\n    plot_datapoints=False,\n    hist_kwargs={\"density\": True},\n    labelpad=0.3,\n)\nplt.suptitle(spnta.model.pulsar_name)\nplt.tight_layout()\nplt.show()","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"The output looks something like this: (Image: NGC6440E_posterior)","category":"page"},{"location":"pyvela/","page":"Getting started: The pyvela interface","title":"Getting started: The pyvela interface","text":"Note that the F0 plot is centered around 0. Refer to Precision for why this is.","category":"page"},{"location":"priors/#Prior-and-Posterior-distributions","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The prior distributions of each free parameter is represented as a Vela.Prior object.   These use the Distributions defined by the Distributions.jl package under the hood. ","category":"page"},{"location":"priors/#Vela.Prior","page":"Prior and Posterior distributions","title":"Vela.Prior","text":"Abstract base class of all priors.\n\n\n\n\n\n","category":"type"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The priors corresponding to Parameters and MultiParameters are represented by two subtypes of Prior.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(Prior)))","category":"page"},{"location":"priors/#Vela.SimplePrior","page":"Prior and Posterior distributions","title":"Vela.SimplePrior","text":"SimplePrior{name,D<:Distribution}\n\nA univariate prior for a single Parameter.\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.SimplePriorMulti","page":"Prior and Posterior distributions","title":"Vela.SimplePriorMulti","text":"SimplePriorMulti{name,index,D<:Distribution}\n\nA univariate prior for a single parameter belonging to a MultiParameter.\n\n\n\n\n\n","category":"type"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Each Prior has lnprior and prior_transform methods which compute  the log-prior distribution  and the prior transform function respectively for that parameter. The former is necessary for MCMC samplers and the latter for nested samplers. Please note that these functions act on Float64s rather than GQs because the samplers  only provide Float64s. A TimingModel also has the lnprior and prior_transform methods; they evaluate  the joint log-prior and the prior transform over all free parameters. The get_lnprior_func and get_prior_transform_func functions return callables that can be passed on to samplers.","category":"page"},{"location":"priors/#Vela.lnprior","page":"Prior and Posterior distributions","title":"Vela.lnprior","text":"Evaluate the log-prior.\n\n\n\n\n\n","category":"function"},{"location":"priors/#Vela.prior_transform","page":"Prior and Posterior distributions","title":"Vela.prior_transform","text":"Evaluate the prior transform function.\n\n\n\n\n\n","category":"function"},{"location":"priors/#Vela.get_lnprior_func","page":"Prior and Posterior distributions","title":"Vela.get_lnprior_func","text":"get_lnprior_func(::TimingModel)::Function\n\nReturns a callable that evaluates the log-prior given a collection of parameter values.\n\n\n\n\n\n","category":"function"},{"location":"priors/#Vela.get_prior_transform_func","page":"Prior and Posterior distributions","title":"Vela.get_prior_transform_func","text":"get_prior_transform_func(::TimingModel)::Function\n\nReturns a callable that evaluates the prior transform given a point within a unit hypercube.\n\n\n\n\n\n","category":"function"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The log-posterior is the sum of the log-likelihood and the log-prior up to an additive  constant. The get_lnpost_func function returns a callable that evaluates the log-posterior  can be passed on to samplers. Note that the expensive log-likelihood is evaluated only if the  log-prior is finite. ","category":"page"},{"location":"priors/#Vela.get_lnpost_func","page":"Prior and Posterior distributions","title":"Vela.get_lnpost_func","text":"get_lnpost_func(::TimingModel, toas::Vector{T}, vectorize::Bool = false) where {T<:TOABase}\n\nReturns a callable that evaluates the log-posterior given a collection of parameter values. If vectorize is true, then the function supports parallel evaluation on different points in the parameter space. \n\n\n\n\n\n","category":"function"},{"location":"priors/#Priors-for-different-parameters","page":"Prior and Posterior distributions","title":"Priors for different parameters","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"In principle, the prior for each parameter has to be set based on our prior knowledge. Indeed, we may have prior information on some of the parameters from previous timing experiments, VLBI  campaigns, detection of counterparts in other parts of the electromagnetic spectrum (e.g., using GAIA), etc. Or priors may be estimated from population statistics using something like  psrcat.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"However, for many parameters, pulsar timing provides so much signal-to-noise ratio that the effect of the prior on the posterior distrubution is entirely negligible. This is the case for parameters like F0, F1, RAJ, DECJ, etc. In such a case, it may be enough to use \"cheat\" priors that are based on the frequentist uncertainties for these parameters (given in the par file). Specifically, we use uniform distributions centered around the frequentist estimate whose width is several times (e.g., 10x) the frequentist uncertainty. Care must be taken to ensure that the data provides enough S/N for the parameter for the \"cheat\" prior to be valid, otherwise we will be effectively  double dipping.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"For some parameters, e.g., the orbital inclination, we have physically motivated default prior distributions.","category":"page"},{"location":"priors/#Vela.KINPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.KINPriorDistribution","text":"KINPriorDistribution\n\nDistribution of KIN = ι when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.SINIPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.SINIPriorDistribution","text":"SINIPriorDistribution\n\nDistribution of SINI = sin(ι) when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.STIGMAPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.STIGMAPriorDistribution","text":"STIGMAPriorDistribution\n\nDistribution of STIGMA = sin(ι)/(1 + cos(ι)) when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/#Vela.SHAPMAXPriorDistribution","page":"Prior and Posterior distributions","title":"Vela.SHAPMAXPriorDistribution","text":"SHAPMAXPriorDistribution\n\nDistribution of SHAPMAX = -ln(1 - sin(ι)) when cos(ι) is uniformly distributed in [0,1].\n\n\n\n\n\n","category":"type"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The preference for the prior distributions is user defined distribution > default distribution > \"cheat\" distribution. Please take care to ensure that the wrong parameter doesn't end up with a \"cheat\" distribution.","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"See the documentation for Distrubutions.jl to see what distributions are available.","category":"page"},{"location":"priors/#Specifying-priors-in-pyvela","page":"Prior and Posterior distributions","title":"Specifying priors in pyvela","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"While creating a pyvela.SPNTA object, the priors are specified using the cheat_prior_scale and custom_priors arguments. ","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The cheat_prior_scale argument defines the scale factor by which the frequentist uncertainties are multiplied to  obtain the \"cheat\" prior widths. ","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The custom_priors argument contains the user-defined prior distributions as a dictionary. It can be a Python dict  or a filename (str) / IO object containing a JSON representation of the dictionary (see below). It supports both parameter  names and prefixes as dict keys.  For example, if an entry for \"EFAC\" is present, it will set the prior for all EFAC  parameters. If \"EFAC1\" is present, it will set the prior for EFAC1 specifically. If both \"EFAC\" and \"EFAC1\" are present,  the latter sets the prior for EFAC1, whereas the former sets the priors for all other EFACs. ","category":"page"},{"location":"priors/#Representing-priors-in-a-JSON-file","page":"Prior and Posterior distributions","title":"Representing priors in a JSON file","text":"","category":"section"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Prior distributions available in Distributions.jl can be represented as a JSON file like so:","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"{\n    \"EFAC\": {\n        \"distribution\": \"LogNormal\",\n        \"args\": [0.0, 0.5]\n    },\n    \"EQUAD\": {\n        \"distribution\": \"LogUniform\",\n        \"args\": [1e-2, 2.0]\n    },\n    \"M2\": {\n        \"distribution\": \"Normal\",\n        \"args\": [0.1, 0.02],\n        \"lower\": 0.0\n    }\n}","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"The distribution attribute for each parameter corresponds to a UnivariateDistribution available in Distributions.jl (see here). args are arguments to the  UnivariateDistribution type's constructor. The lower and upper attributes represent the lower and  upper bounds for truncating the distribution (see truncated).","category":"page"},{"location":"priors/","page":"Prior and Posterior distributions","title":"Prior and Posterior distributions","text":"Note that the values above should be given in their \"normal\" units as they appear in the par files.  Specifically, the prior on M2 corresponds  to 0.1 ± 0.02 Msun, where the normal distribution is truncated  at a lower bound of 0. ","category":"page"},{"location":"likelihood/#The-Likelihood-Function-and-Kernels","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"","category":"section"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The pulsar timing log-likelihood function is given by ","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"ln L = -frac12r^T C^-1 r - frac12ln det C","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"where r is contains the residuals (both time & DM residuals in the case of wideband timing), and C is the covariance matrix incorporating the measurement uncertainties and the various correlated noise  processes. C is represented by a Kernel.","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The calc_lnlike() and calc_lnlike_serial() functions compute this log-likelihood function. The difference between them is that the former parallelizes the computation using threads over TOAs whereas the latter  executes serially. ","category":"page"},{"location":"likelihood/#Vela.calc_lnlike","page":"The Likelihood Function and Kernels","title":"Vela.calc_lnlike","text":"calc_lnlike(::TimingModel, ::Vector{T}, params)::Float64 where {T<:TOABase}\n\nCompute the log-likelihood value for a given timing model and collection of TOAs  (parallel execution).\n\nReference:     Lentati+ 2014\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Vela.calc_lnlike_serial","page":"The Likelihood Function and Kernels","title":"Vela.calc_lnlike_serial","text":"calc_lnlike_serial(::TimingModel, ::Vector{T}, params)::Float64 where {T<:TOABase}\n\nCompute the log-likelihood value for a given timing model and collection of TOAs  (serial execution).\n\nReference:     Lentati+ 2014\n\n\n\n\n\n","category":"function"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The get_lnlike_func() function returns a callable that can be passed on to sampling packages. It chooses parallel or serial execution based on the number of available threads. It also has a vectorize option that evaluates the likelihood function over multiple sets of parameters parallely. This is supported by some samplers like emcee, and is more efficient than parallelizing over TOAs. There is also a get_lnlike_serial_func() function that always returns the serial version of the callable.","category":"page"},{"location":"likelihood/#Vela.get_lnlike_func","page":"The Likelihood Function and Kernels","title":"Vela.get_lnlike_func","text":"get_lnlike_func(model, toas)::Function\n\nGet the log_likelihood(params) function for a given timing model and collection of TOAs. Serial or parallel execution is decided based on the number of available threads.\n\nSupports both narrowband and wideband TOAs.\n\nUse get_lnlike_serial_func(model, toas) to force serial execution of the likelihood.  The serial version should be used if parallelization is to be implemented at a different level  (e.g., within the sampling method).\n\nReference:     Lentati+ 2014,     Alam+ 2021,     Johnson+ 2024\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Vela.get_lnlike_serial_func","page":"The Likelihood Function and Kernels","title":"Vela.get_lnlike_serial_func","text":"get_lnlike_serial_func(model, toas)::Function\n\nVersion of get_lnlike_func that always does serial execution.\n\n\n\n\n\n","category":"function"},{"location":"likelihood/#Kernels","page":"The Likelihood Function and Kernels","title":"Kernels","text":"","category":"section"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"The matrix operations appearing in the likelihood function expression are evaluated with the help of Kernel objects.","category":"page"},{"location":"likelihood/#Vela.Kernel","page":"The Likelihood Function and Kernels","title":"Vela.Kernel","text":"Kernel\n\nAbstract base class of all likelihood kernels\n\n\n\n\n\n","category":"type"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"Three types of Kernels are currently supported.","category":"page"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"using InteractiveUtils\nusing AbstractTrees\nusing Vela\nusing Markdown\n\nAbstractTrees.children(d::DataType) = subtypes(d)\nMarkdown.MD(Markdown.Code(repr_tree(Kernel)))","category":"page"},{"location":"likelihood/#Vela.WhiteNoiseKernel","page":"The Likelihood Function and Kernels","title":"Vela.WhiteNoiseKernel","text":"WhiteNoiseKernel\n\nA kernel representing only uncorrelated noise. The covariance matrix is diagonal.\n\nReference:     Hobbs+ 2006,     Alam+ 2021\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#Vela.EcorrKernel","page":"The Likelihood Function and Kernels","title":"Vela.EcorrKernel","text":"EcorrKernel\n\nA kernel representing white noise and ECORR. The covariance matrix is block-diagonal. Assumes that the TOAs are sorted in the correct order. Not applicable for wideband TOAs.\n\nReference:     Johnson+ 2024\n\n\n\n\n\n","category":"type"},{"location":"likelihood/#Vela.WoodburyKernel","page":"The Likelihood Function and Kernels","title":"Vela.WoodburyKernel","text":"WoodburyKernel\n\nA kernel representing white noise and correlated noise including ECORR.\n\nThis type has an inner_kernel attribute which represents the time-uncorrelated part of the timing noise. It can be a WhiteNoiseKernel if the only time-uncorrelated noise is white noise, or EcorrKernel if ECORR noise is also present.\n\nThe gp_components attribute contains a collection of amplitude-marginalized Gaussian  noise components. These are treated as part of the covariance matrix. WoodburyKernel.gp_components and TimingModel.components must have no common elements.\n\nReference:     Johnson+ 2024\n\n\n\n\n\n","category":"type"},{"location":"likelihood/","page":"The Likelihood Function and Kernels","title":"The Likelihood Function and Kernels","text":"More details about the implementation of time-correlated noise is given in Red noise models.","category":"page"},{"location":"#Vela.jl","page":"Home","title":"Vela.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Bayesian pulsar timing and noise analysis package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Vela.jl project aims to develop a fast and simple-to-use framework for doing Bayesian pulsar timing & noise analysis. It currently supports both narrowband and wideband TOAs along  with most commonly used pulsar timing models. It can be used from Julia REPL, scripts, or  notebooks. It can also be used from Python REPL, scripts, and notebooks with the help of the  pint2vela interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Vela.jl is named after the brightest radio pulsar, the Vela pulsar (J0835-4510). Also, Vēḻa (വേള) is a word meaning occasion, time, etc. in the Malayalam language with cognates in  many other Indian languages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"It is under active development.","category":"page"},{"location":"toas/#Pulse-Times-of-Arrival-(TOAs)","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"","category":"section"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"The TOA is the fundamental measurable quantity in conventional pulsar timing. They are measured my folding the time series observations using a known pulsar ephemeris, and then matching the  resulting integrated pulse profile against a template. This procedure produces a TOA measurement (usually expressed as an MJD measured against the observatory clock) along with an uncertainty which is assumed to be Gaussian. The TOA measurements and uncertainties, along with some metadata  (such as observing frequency, observatory name, observatory reciever and backend information, etc) is saved in a text file known as a tim file. Often, multiple TOAs are measured from the same  observation by splitting it into multiple frequency sub-bands. This is known as narrowband timing.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"Alternatively, we can measure a TOA and a dispersion measure simultaneously from an observation  using the wideband timing method (Pennucci 2019).  This is useful for dealing with frequency-dependent profile evolution more accurately. It also  helps reduce the number of TOAs significantly, thus reducing the computational cost of analyzing  them.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"In Vela.jl, all TOAs are represented by the abstract type TOABase. Narrowband TOAs are represented using the TOA type and wideband TOAs are represented by the WidebandTOA type. The latter is a composition of a TOA object and a DMInfo object that represents a wideband DM measurement.","category":"page"},{"location":"toas/#Vela.TOABase","page":"Pulse Times of Arrival (TOAs)","title":"Vela.TOABase","text":"TOABase\n\nAbstract base type of all TOAs.\n\n\n\n\n\n","category":"type"},{"location":"toas/#Vela.TOA","page":"Pulse Times of Arrival (TOAs)","title":"Vela.TOA","text":"TOA\n\nA single narrowband TOA observation.\n\nvalue is the TOA in the TDB timescale incorporating the clock corrections. ephem contains the solar system ephemerides. These are computed using PINT.\n\nReferences:     Hobbs+ 2006,     Luo+ 2021\n\n\n\n\n\n","category":"type"},{"location":"toas/#Vela.DMInfo","page":"Pulse Times of Arrival (TOAs)","title":"Vela.DMInfo","text":"DMInfo\n\nDM information associated with a wideband TOA.\n\nReferences:     Pennucci+ 2014,     Pennucci 2019\n\n\n\n\n\n","category":"type"},{"location":"toas/#Vela.WidebandTOA","page":"Pulse Times of Arrival (TOAs)","title":"Vela.WidebandTOA","text":"WidebandTOA\n\nA single wideband TOA observation.\n\ntoa.value is the wideband TOA measurement in the TDB frame incorporating the clock  corrections. toa.ephem contains the solar system ephemerides. These are computed using  PINT.\n\nReferences:     Pennucci+ 2014,     Pennucci 2019,     Luo+ 2021\n\n\n\n\n\n","category":"type"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"A TOA object contains the clock-corrected TOA value in the TDB timescale, uncertainty, and  observing frequency, along with the solar system ephemeris evaluated at that instance. The clock corrections  from the observatory timescale to TDB and the solar system ephemeris computations are precomputed using PINT, which in turn uses astropy underneath.  The evaluated solar system ephemerides are represented using the SolarSystemEphemeris type.","category":"page"},{"location":"toas/#Vela.SolarSystemEphemeris","page":"Pulse Times of Arrival (TOAs)","title":"Vela.SolarSystemEphemeris","text":"SolarSystemEphemeris\n\nStruct containing solar system ephemeris vectors corresponding to a TOA.\n\nThese are computed using PINT, which uses the JPL ephemerides internally.\n\nReferences:     Hobbs+ 2006,     Luo+ 2021\n\n\n\n\n\n","category":"type"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"The TOA objects do not contain any other metadata unlike the PINT TOAs objects or  the tempo2 observation objects. Everything that depend on the metadata are precomputed and  stored elsewhere. This helps with computational efficiency by avoiding repeated string operations.","category":"page"},{"location":"toas/","page":"Pulse Times of Arrival (TOAs)","title":"Pulse Times of Arrival (TOAs)","text":"A performance-critical assumption made in Vela.jl is that the TOAs are immutable. This assumption  is not possible in general pulsar timing packages such as tempo2 and PINT since they allow interactive removal and flagging of TOAs. Vela.jl does not have this use case since it is only meant to do pulsar timing & noise analysis on TOAs that have already gone through data combination & timing stages.","category":"page"},{"location":"residuals/#Residuals","page":"Residuals","title":"Residuals","text":"","category":"section"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"The timing residual corresponding to a TOA can be computed using the form_residual function. This function also returns the DM residual in the case of wideband data.","category":"page"},{"location":"residuals/#Vela.form_residual","page":"Residuals","title":"Vela.form_residual","text":"form_residual(::TimingModel, ::TOA, params::NamedTuple, tzrphase::GQ)::GQ\n\nCompute the timing residual corresponding to a single narrowband TOA.\n\n\n\n\n\nform_residual(::TimingModel, ::WidebandTOA, params::NamedTuple, tzrphase::GQ)::Tuple{GQ, GQ}\n\nCompute the timing and DM residuals corresponding to a single wideband TOA.\n\n\n\n\n\n","category":"function"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"Under the hood, it calls the correct_toa method for each component, and computes the phase residual, which is the computed phase modulo 1 (this is done using the phase_residual function). The timing residual is the phase residual divided by the topocentric spin frequency (computed using  doppler_shifted_spin_frequency).","category":"page"},{"location":"residuals/","page":"Residuals","title":"Residuals","text":"The form_residuals function computes the residuals for a collection of TOAs.","category":"page"},{"location":"residuals/#Vela.form_residuals","page":"Residuals","title":"Vela.form_residuals","text":"form_residuals(::TimingModel, ::Vector{TOA}, params::NamedTuple)::Vector{GQ}\n\nCompute the timing residuals corresponding to a collection of narrowband TOAs.\n\n\n\n\n\nform_residuals(::TimingModel, ::Vector{WidebandTOA}, params::NamedTuple)::Vector{Tuple{GQ, GQ}}\n\nCompute the timing and DM residuals corresponding to a collection of wideband TOAs.\n\n\n\n\n\n","category":"function"}]
}
